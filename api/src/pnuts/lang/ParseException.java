/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 0.7pre6 */
package pnuts.lang;

/**
 * This exception is thrown when parse errors are encountered. You can
 * explicitly create objects of this exception type by calling the method
 * generateParseException in the generated parser.
 * 
 * You can modify this class to customize your error reporting mechanisms so
 * long as you retain the public fields.
 */
public class ParseException extends Exception {

    Object scriptSource;

	/**
	 * This constructor is used by the method "generateParseException" in the
	 * generated parser. Calling this constructor generates a new object of this
	 * type with the fields "currentToken", "expectedTokenSequences", and
	 * "tokenImage" set. The boolean flag "specialConstructor" is also set to
	 * true to indicate that this constructor was used to create this object.
	 * This constructor calls its super class with the empty string to force the
	 * "toString" method of parent class "Throwable" to print the error message
	 * in the form: ParseException: <result of getMessage>
	 */
	public ParseException(Token currentTokenVal,
			int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
		super("");
		specialConstructor = true;
		currentToken = currentTokenVal;
		expectedTokenSequences = expectedTokenSequencesVal;
		tokenImage = tokenImageVal;
		init();
	}

	/**
	 * The following constructors are for use by you for whatever purpose you
	 * can think of. Constructing the exception in this manner makes the
	 * exception behave in the normal way - i.e., as documented in the class
	 * "Throwable". The fields "errorToken", "expectedTokenSequences", and
	 * "tokenImage" do not contain relevant information. The JavaCC generated
	 * code does not use these constructors.
	 */

	public ParseException() {
		super();
		specialConstructor = false;
	}

	public ParseException(String message) {
		super(message);
		specialConstructor = false;
	}

	/**
	 * This variable determines which constructor was used to create this object
	 * and thereby affects the semantics of the "getMessage" method (see below).
	 * 
	 * @serial
	 */
	protected boolean specialConstructor;

	/**
	 * This is the last token that has been consumed successfully. If this
	 * object has been created due to a parse error, the token followng this
	 * token will (therefore) be the first error token.
	 * 
	 * @serial
	 */
	public Token currentToken;

	/**
	 * Each entry in this array is an array of integers. Each array of integers
	 * represents a sequence of tokens (by their ordinal values) that is
	 * expected at this point of the parse.
	 * 
	 * @serial
	 */
	public int[][] expectedTokenSequences;

	/**
	 * This is a reference to the "tokenImage" array of the generated parser
	 * within which the parse error occurred. This array is defined in the
	 * generated ...Constants interface.
	 * 
	 * @serial
	 */
	public String[] tokenImage;

	int errorLine = -1;

	int errorColumn = -1;

	String errorName;

	String errorWord = null;

	public int getErrorLine() {
		return errorLine;
	}

	public int getErrorColumn() {
		return errorColumn;
	}

	public void setScriptSource(Object scriptSource){
		this.scriptSource = scriptSource;
	}

	public Object getScriptSource(){
		return this.scriptSource;
	}

	void init() {
		int maxSize = 0;
		for (int i = 0; i < expectedTokenSequences.length; i++) {
			if (maxSize < expectedTokenSequences[i].length) {
				maxSize = expectedTokenSequences[i].length;
			}
		}

		StringBuffer retval = new StringBuffer("");
		Token tok = currentToken.next;
		Token tok2 = tok;

		for (int i = 0; i < maxSize; i++) {
			if (tok.kind == 0) {
				retval.append(tokenImage[0]);
				break;
			}
			if (tok.kind == PnutsParserConstants.EOL) {
				tok = tok.next;
				tok2 = tok;
				retval = new StringBuffer("");
				continue;
			}
			if (i > 0){
				retval.append(" ");
			}
			retval.append(add_escapes(tok.image));
			tok = tok.next;
		}
		if (tok2 == null) {
			tok2 = currentToken;
		}
		errorName = "parse.error";
		errorLine = tok2.beginLine;
		errorColumn = tok2.beginColumn;
		errorWord = retval.toString();
	}

	/**
	 * This method has the standard behavior when this object has been created
	 * using the standard constructors. Otherwise, it uses "currentToken" and
	 * "expectedTokenSequences" to generate a parse error message and returns
	 * it. If this object has been created due to a parse error, and you do not
	 * catch it (it gets thrown from the parser), then this method is called
	 * during the printing of the final stack trace, and hence the correct error
	 * message gets displayed.
	 */
	public String getMessage() {
		if (!specialConstructor) {
			return super.getMessage();
		}
		String msg = Runtime.getMessage("pnuts.lang.pnuts", errorName, new Object[] {
				errorWord, new Integer(errorLine), new Integer(errorColumn) });
		if (scriptSource != null){
		    return "[" + scriptSource + "] " + msg;
		} else {
		    return msg;
		}
	}

	/**
	 * The end of line string for this machine.
	 * 
	 * @serial
	 */
	protected String eol = System.getProperty("line.separator", "\n");

	/**
	 * Used to convert raw characters to their escaped version when these raw
	 * version cannot be used as part of an ASCII string literal.
	 */
	protected String add_escapes(String str) {
		StringBuffer retval = new StringBuffer();
		char ch;
		for (int i = 0; i < str.length(); i++) {
			switch (str.charAt(i)) {
			case 0:
				continue;
			case '\b':
				retval.append("\\b");
				continue;
			case '\t':
				retval.append("\\t");
				continue;
			case '\n':
				retval.append("\\n");
				continue;
			case '\f':
				retval.append("\\f");
				continue;
			case '\r':
				retval.append("\\r");
				continue;
			//           case '\"':
			//              retval.append("\\\"");
			//              continue;
			//           case '\'':
			//              retval.append("\\\'");
			//              continue;
			//           case '\\':
			//              retval.append("\\\\");
			//              continue;
			default:
				if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
					String s = "0000" + Integer.toString(ch, 16);
					retval.append("\\u"
							+ s.substring(s.length() - 4, s.length()));
				} else {
					retval.append(ch);
				}
				continue;
			}
		}
		return retval.toString();
	}
}
