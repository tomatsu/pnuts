<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Pnuts 言語</title>
  <META Http-Equiv="Content-Type" content="text/html; charset=EUC-JP">
  <META Http-Equiv="Content-Style-Type" Content="text/css">
  <LINK Type="text/css" Rel="stylesheet" Href="stylesheet.css">
</head>

<body>

<div class="nav"><a href="lang-TOC.html">目次</a> -> Pnuts 言語</div>

<!-- body start -->

<center><h1>Pnuts 言語</h1></center>
<center>バージョン1.2.1</center>

<a name=basics></a>
<h2>1. 基本的概念</h2>

<a name=structure></a>
<h3>基本的構造</h3>

<h4>式の列</h4>
<p>
Pnutsのプログラムは、普通は式の列として書かれます。
スクリプトが実行されると、それらの式は１つずつ評価され、最後の式の結果が全体の結果になります。
</p>
<div class="eg">
<pre>
<em>式 1</em>
<em>式 2</em>
...
<em>式 n</em>
</pre></div>

<h4>クラス定義</h4>
<p>
Pnutsは、明示的なコンパイルを行うことなくJavaクラスを作成することができます。
共通のファイル名拡張子 '<tt>.pnc</tt>'を持つスクリプトファイルは、そのクラスが必要になったときに、
特別なクラスローダによって、コンパイル、ロードされます。
</p>
<div class="eg">例：
<pre>
class A {
  int field_1 = 0
  int method (parameter){
    ...
  }
}
</pre></div>
<p>
クラス定義の詳細については<a href="#classdef">「4. クラス定義」</a>を参照。
</p>
<a name=expression></a>
<h3>式</h3>
<p>
Pnuts言語のプログラムは式の列です。スクリプトを実行すると、その中の式が順に評価され、最後の式の結果が実行結果になります。
</p>
<p>
<a href="#expressions">「3. 式」</a>を参照。
</p>

<a name=variables></a>
<h3>変数</h3>
<p>
変数は任意のオブジェクトを参照します。変数には型がなく、代入を行うことで変数が定義されます。
</p>

<a name=functions></a>
<h3>関数</h3>

<p>
関数は、関数名、パラメータ・リスト、式の列から定義されます。
</p>
<p>
関数はファーストクラスのオブジェクトです。つまり、関数を変数に代入することができます。
</p>
<p>
関数は、名前とパラメータ数で識別され、いずれかが異なる関数を複数同時に定義することができます。同じスコープでおなじ名前の関数(1つとはかぎらない)は一つのグループとして関数名で参照されます。関数を呼び出すために、関数の名前と括弧で括った実引数の列を与えると、まずその名前の関数グループを参照し、引数の数が合致する関数定義を検索します。見つかればその関数定義が実行されます。
</p>
<p>
関数はネストすることができ、変数のスコープとしてレキシカルスコープを持ちます。
</p>

<div class="eg">例1:
<pre>
function f(){
   x = 0
   function set(value) x = value
   function get() x
   ::set = set
   ::get = get
}

f()
set(100)
get()     --> 100
f()
get()     --> 0
</pre></div>

<div class="eg">例2:
<pre>
function inc(x) ++x
function abs(x) if (x < 0) -x else x

function compose (f1, f2) return (function (x) f1(f2(x)))
compose(inc, abs)(-100)  --> 101
compose(abs, inc)(-100)  --> 99
</pre></div>

<a name=packages></a>
<h3>パッケージ</h3>

<p>
パッケージは名前空間を作ります。関数や変数はあるパッケージに属します。そして、常にあるパッケージが一つ選択された状態になっており、<em>カレントパッケージ</em>と呼ばれます.
</p>

<p>
関数は定義されたときのパッケージで実行されます。
</p>

<a name="package_hierarchy"></a>
<a name="root_package"></a>
<a name="global_package"></a>

<h4>パッケージの階層</h4>
<p>パッケージはそれぞれ親パッケージを持つことができます。パッケージ変数に対して読み込みが行われるとき、その変数がそのパッケージで定義されている場合はその値を返しますが、定義されていない場合は、Pnutsの実行環境はその親パッケージからその変数を探します。
</p>
<p>パッケージの階層は、パッケージ変数に対する書き込みには関係ありません。あるパッケージでの代入は、親のパッケージには影響をおよぼしません。
</p>
<p>
パッケージ階層の最上部、つまり親のないパッケージは<em>ルート・パッケージ</em>と呼ばれます。システム中に一つだけ<em>グローバル・パッケージ</em>と呼ばれるルート・パッケージがあり、デフォルトのカレント・パッケージになります。
</p>

<a name=context></a>
<h3>コンテクスト</h3>
<p>
<em>コンテクスト</em> とは、Pnuts の実行環境の内部的なデータを保持するオブジェクトです。スクリプトの実行を開始するときに作成され、実行が終了するまで同じコンテクストが使われます。ただし、スクリプトから別のスクリプトを呼び出した場合には、コンテクストのクローンが作られて、呼び出されたスクリプトではクローンの方が使われます。
</p>

<a name=modules></a>
<h3>モジュール</h3>


<p>
モジュールとは、再利用性可能なスクリプトを部品化するためのしくみです。
ユーザは必要なモジュールを組込み関数<a href="#use"><tt>use()</tt></a>で指定するだけで、そのモジュールが用意する機能を利用することができます。
<p>
各モジュールは通常別々のJARファイルにパッケージ化されます。そして、そのJARファイルはCLASSPATHに追加されるか${PNUTS_HOME}/modules/にコピーしておきます。
<p>
Pnutsインタープリタの中では、モジュールは、名前空間を形成する"パッケージ"の拡張として実装されます。モジュールが定義(公開)する関数やオブジェクトは、あるパッケージに定義されます。通常のパッケージに定義された名前は、そのパッケージがカレント・パッケージの時にはその名前で参照できますが、様々なパッケージに様々な名前が定義されていた場合、各々の名前を参照するためにカレント・パッケージを変更するのはとてもたいへんです。モジュールに定義される名前は、カレント・パッケージに関らず、そのモジュールを利用中のときに、その名前で参照できます。
</p>

<p>
<b><em>初期化スクリプト</em></b>
</p>
<p>
モジュールを登録するとき、指定したモジュールに対応した初期化スクリプト
が読み込まれます。
モジュールが定義する名前(関数)は、初期化スクリプトを読み込んだ時点で定義済になるか、あるいは、<tt>autoload()</tt>を使って、参照時に定義されるようにしなければなりません。
</p>
<p>
パッケージ名を"<tt>::</tt>" か "<tt>.</tt>" で区切った文字列の後ろに "/init" をつけたものが初期化スクリプトの名前になります。たとえば、パッケージ名が "<tt>a.b.c</tt>" の場合、"<tt>a/b/c/init</tt>" という名前のスクリプトが読み込まれます。
</p>

<p>
<b><em>エクスポートされるシンボル</em></b>
<p>
デフォルトの振舞いとして、シンボルが同じ名前の関数を参照している場合に、そのシンボルが自動的にエクスポートされます。
<p>
Pnuts APIを使うと、モジュールの作成者はエクスポートされるシンボルを定義することができます。
</p>
<p>
<b><em>名前の衝突</em></b>
</p>
<p>
複数のモジュールで同じ名前の関数が登録された場合は、後で登録されたモジュールが優先されます。
</p>

<p>
<b><em>モジュールとコンテクストの関係</em></b>
</p>

<p>
コンテクストは、一つずつ追加されたモジュールを、<em>モジュール・リスト</em>として保管しています。
<p>
通常、モジュール・リストは、コンテクストのクローン間で共有されます。つまり、<tt>load()</tt>, <tt>loadFile()</tt>などの関数で呼び出されたスクリプトでは、元のコンテクストのモジュール・リストを利用できますし、また、呼び出されたスクリプトで新たに追加されたモジュールは、元のコンテクストにも反映されます。
<p>
<img src="../doc/images/modulelist.png"></img>
<p>
<a name="branch_module_list"></a>
<b><em>モジュール・リストの枝分かれ</em></b>
<p>
複数のモジュールで同じ名前の関数が定義された場合、後で登録したモジュールが優先されます。先に登録されたモジュールの関数は後から登録されたモジュールの関数に隠されてしまうことがあります。同じスクリプトでも実行時のモジュール・リストの状態しだいで動作が異なるのは、多くの場合望ましいことではありません。
<p>
この問題を避けるには、モジュールを定義するときには、登録時にどのようなモジュール・リストであるかを仮定してくてもよいように、初期化スクリプトで<a href="#use"><tt>use(null)</tt></a>を呼び出し、空の状態のモジュール・リストを作ります。
</p>
<img src="../doc/images/modulelist2.png"></img>
<p>
モジュール・リストが一旦リセットされると、それ以降に登録されるモジュールは、そのコンテクストの新しいモジュールリストに追加されます(元のモジュール・リストには追加されません)。
<p>
例えば、モジュールAの初期化スクリプトで、<tt>use(null)</tt>を呼び出す前でモジュールBを<tt>use()</tt>し、呼び出した後でモジュールCを<tt>use()</tt>すると、モジュールAを利用するコンテクストではモジュールBも同時に利用できる状態になります(モジュールCは利用できません)。モジュールAの実装ではモジュールCが利用できます(モジュールBは利用できません)。
<p>

<pre class="eg">
use(B)
use(null)
use(C)
</pre>

<p>
<b><em>モジュールと関数呼び出しの関係</em></b>
</p>
<p>
関数は定義時のモジュールリストを使って実行されます。
</p>

例えば、次の2つのスクリプトがロードされるとします。

<div class="eg">m1.pnut
<pre>
use("pnuts.lib")
function mymap() map()
</pre></div>

<div class="eg">m2.pnut
<pre>
use("functional")
map     --> function map(func, list) // in "functional"
mymap() --> {}                     // map() in "pnuts.lib"
</pre></div>

<p>
<tt>pnuts.lib</tt>モジュールと<tt>functional</tt>モジュールの両方で<tt>map</tt>関数が定義されてい
ます。
シンボルは定義時のモジュール・リストを使って解決されるため、どちらのスクリプトファイルが
先にロードされても、<tt>mymap()</tt>が参照するのは<tt>pnuts.lib</tt>モジュールの<tt>map</tt>になります。
<p>


<a name=scope></a>
<h3>スコープ規則</h3>
<h4>スコープクラスの定義</h4>
<dl>
  <dt>静的スコープ
  <dd>
  <dl>
    <dt>ローカル・スコープ
    <dt>トップレベル・スコープ
  </dl>
  <dt>動的スコープ
  <dd>
  <dl>
    <dt>カレントパッケージ
    <dt>組み込み関数
    <dt>利用中のモジュールの関数
    <dt>importされたクラス名
    <dt>パッケージ階層
  </dl>
</dl>
<p>
<b>ローカル・スコープ</b> は、関数内で宣言される変数に対するスコープクラスです。
<p>
ローカル・スコープの変数は、関数内で変数に値を代入することで宣言されます。
ローカル・スコープの変数は、その変数を宣言した関数内でのみ使うことができます。

<div class="eg">例:
<pre>
a = 1
function t1(){
  a = 0
  println(a)
}
t1()  // 0
println(a) // 1
</pre></div>

<p>
条件文の中で宣言されたローカル変数は、実行時に値が代入されない場合はnullに初期化されます。
</p>

<div class="eg">例:
<pre>
function t1(){
  if (false){
      a = 0
  }
  println(a)
}

function t2(){
  while (false){
      a = 0
  }
  println(a)
}

t1()    // null
t2()    // null
</pre></div>


<p>
関数が入れ子になっている場合、外側の関数で宣言された変数は、内側の関数で読んだり書いたりすることができます。
</p>

<div class="eg">例:
<pre>
a = 1
function t1(){
  a = 0
  function t2(){
    a = 4
  }
  t2()
  println(a + " should be 4")
}
</pre></div>

<p>for/foreach文のカウンタ変数のスコープもローカル・スコープに分類されますが、
外側のスコープに影響を与えません。</p>
<div class="eg">例:
<pre>
function t3 (){
  a = 2
  for (a : 0..9){
    println(a)
  }
  println(a + " should be 2")
}
</pre></div>


<p><a name="resolution"></a><b>トップレベル・スコープ</b>は、関数の外側で宣言される変数に対するスコープクラスです。
ローカル・スコープで定義されていない変数が参照されると、トップレベル・スコープでその変数が参照されます。
</p>
<p>
トップレベル・スコープの変数の名前の解決は、次の順序で行われます。
</p>
<ol>
  <li>カレント・パッケージ
  <li>組み込み関数
  <li>利用中のモジュールの関数
  <li><tt>import()</tt>されたクラス名
  <li>パッケージ階層
</ol>
<p>
トップレベル・スコープで変数が宣言されると、その変数はカレントパッケージで定義されます。
</p>

<p>
トップレベル・スコープの変数がローカル・スコープで参照される場合、変数の参照ごとに名前の解決が行われるとはかぎりません。ある実装では、トップレベル・スコープからローカル・スコープに入る直前で変数の解決を行います。また、ある実装では、変数が参照される度に変数を解決します。しかし、その振舞いに頼ったスクリプトを書くべきではありません。
</p>

<p>
たとえば、次の関数は定義内で<tt>import()</tt>を呼んでいますが、トップレベル・スコープからローカル・スコープに入る直前で変数の解決を行う実装では変数の解決に失敗してしまうため、このような使い方は推奨されません。
</p>
<pre class="eg">
function foo(){
  import("java.util.HashMap")
  HashMap()
}
</pre>

<a name=lexicalElements></a>
<h2>2. 字句要素</h2>

<a name=keywords></a>
<h3>予約語</h3>

<table width=400>
<tr align=center>
<td><tt>function</tt></td>
<td><tt>if</tt></td>
<td><tt>else</tt></td>
<td><tt>while</tt></td>
<td><tt>do</tt></td>
<td><tt>for</tt></td>
<td><tt>foreach</tt></td>
<td><tt>switch</tt></td>
<td><tt>case</tt></td>
<td><tt>default</tt></td>
<td><tt>break</tt></td>
<td><tt>new</tt></td>
<td><tt>yield</tt></td>
</tr>
<tr align=center>
<td><tt>null</TT></td>
<td><tt>try</TT></td>
<td><tt>catch</TT></td>
<td><tt>finally</TT></td>
<td><tt>continue</tt></td>
<td><tt>return</tt></td>
<td><tt>true</tt></td>
<td><tt>false</tt></td>
<td><tt>instanceof</tt></td>
<td><tt>class</tt></td>
<td><tt>import</tt></td>
<td><tt>macro</tt></td>
<td><tt>throw</tt></td>
<td><tt>static</tt></td>
</tr>
</table>

<a name=comments></a>
<h3>コード中のコメント</h3>

<p>
<tt>//</tt> から行末までと、<tt>/*</tt>と<tt>*/</tt>の間は無視されます。
</p>

<a name=character></a>
<h3>文字リテラル</h3>

<p>
文字リテラルは <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Character.html"><tt>java.lang.Character</tt></a>オブジェクトを表します。
文字に関する字句規則は Java と同じです。
</p>

<div class="eg">例:
<pre>
'A'
</pre></div>

以下の文字は特殊文字です。
<pre class="eg">
'\''   --> '
'\n'   --> LF
'\t'   --> TAB
'\r'   --> CR
'\f'   --> ^L
'\b'   --> ^H
'\\'   --> \
'\0'   --> NUL
</pre>

文字リテラルの中でUnicode のエスケープシーケンスを使うことができます。
<pre class="eg">
'\u0041'   --> 'A'
</pre>


<a name=string></a>
<h3>文字列リテラル</h3>

<p>
&quot;(ダブルクオート)で囲まれた文字リテラルは文字列リテラルで、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/String.html">java.lang.String</a>オブジェクトを表します。
</p>

<pre class="eg">
> "foo"
"foo"

> "\b"
"^H"
</pre>

文字列リテラルの一部としてUnicode のエスケープシーケンスを使うことができます。

<pre class="eg">
"\u0041B" --> "AB"
</pre>

\( と \) の間の文字列は式だと解釈され、実行結果が両側の文字列の間に埋め込まれます。

<pre class="eg">
"Date: \(date()\)"     ---> "Date: Fri May 11 00:11:31 GMT 2007"
</pre>


<p>
`(バッククオート)で囲まれた文字の列は、どんな文字もエスケープしない文字列リテラルです。
</p>

<pre class="eg">
`x = "A"` --> "x = \"A\""
`ABC\` --> "ABC\\"
</pre>

<a name=integer></a>
<h3>整数</h3>

<p>
整数は <em>long</em> 型が表せる範囲に制限されません。値の大きさに応じて数値を表
すクラスが割り当てられます。整数が Integer.MAX_VALUE と Integer.MIN_VALUE の間に
ある場合は <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Integer.html"><tt>java.lang.Integer</tt></a>、Long.MAX_VALUE と Long.MIN_VALUE の間にある場合は 
<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Long.html"><tt>java.lang.Long</tt></a>、それ以外の場合は <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/math/BigInteger.html"><tt>java.math.BigInteger</tt></a> オブジェクトになります。
</p>

<p>
java.math package がサポートされない <a href="http://java.sun.com/products/personaljava/">Personal Java</a> 環境では、<em>long</em> の範囲を越える整数は<em>Double</em> オブジェクトとして表されます。
</p>

<h4>10進数</h4>

<blockquote>
("0" | ["1"-"9"] (["0"-"9"])*)
</blockquote>

<div class="eg">例
<pre>
123
12345678901234567890
123L
</pre></div>

<h4>16進数</h4>

<pre class="eg">
"#" (["0"-"9","a"-"f","A"-"F"])+
"0" ("X"|"x") (["0"-"9","a"-"f","A"-"F"])+
</pre>

<div class="eg">例:
<pre>
#ffff
#ffff0000
0xff
</pre></div>

<p>
数値が <tt>Byte.MAX_VALUE</tt> と <tt>Byte.MIN_VALUE</tt> の間にある場合、
"<tt>#ff</tt>" という形式の数は Byte オブジェクトになり、
"<tt>0xff</tt>" という形式の数は Integer オブジェクトになります。
</p>

<h4>8進数</h4>

<div class="eg">例: <pre>
0777
0177L
</pre></div>

<a name=floating></a>
<h3>浮動小数点数</h3>

<p>
浮動小数点数は、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Double.html"><tt>java.lang.Double</tt></a>または、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Float.html"><tt>java.lang.Float</tt></a>で表されます。
</p>

<div class="eg">例:
<pre>
123F    --> new Float(123.0)
123f    --> new Float(123.0)
123D    --> new Double(123.0)
123d    --> new Double(123.0)
123.0   --> new Double(123.0)
123.0f   --> new Float(123.0)
1.23E-4   --> new Double(1.23E-4)
1.23E-4f   --> new Float(1.23E-4)
</pre></div>

<a name=decimal></a>
<h3>多倍長10進数</h3>

<p>
多倍長10進数は、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/math/BigDecimal.html"><tt>java.math.BigDecimal</tt></a>で表されます。
</p>

<div class="eg">例:
<pre>
123.0B   --> new BigDecimal("123.0")
123.0E-4B   --> new BigDecimal("0.00123")
              
1.2 * 3  --> 3.5999999999999996
1.2B * 3 --> 3.6
</pre></div>

<p>
java.math パッケージがサポートされない<a href="http://java.sun.com/products/personaljava/">Personal Java</a>環境では、'B' は無視されます。
</p>

<a name=boolean></a>
<h3>論理値リテラル</h3>

<p>
論理値リテラルは、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Boolean.html"><tt>java.lang.Boolean</tt></a>オブジェクトを表します。
</p>

<blockquote>
<DL>
  <dt><tt>true</tt></dt>
  <dt><tt>false</tt></dt>
</DL>
</blockquote>

<a name=null></a>
<h3>null リテラル</h3>

Java の <tt>null</tt> を表します。

<a name=classliteral></a>
<h3>クラス・リテラル</h3>
<p>
クラス・リテラルは、Java言語のクラスを表します。クラス・リテラルは、それ自体は値を持ちません。
<a href="#new"><tt>new</tt>式</a>や、<a href="#try">try/catch/finally文</a>の<tt>catch</tt>部分で使われます。
</p>
<pre class="eg">
java.util.Integer
</pre>

<a name=typeLiteral></a>
<h3>型リテラル</h3>
<p>
型リテラルは、Java言語の型を表します。型リテラルは、それ自体は値を持ちません。
<a href="#cast">キャスト</a>や<a href="#instanceof">instanceof式</a>で使われます。
型リテラルは、クラス・リテラルの他、配列型、プリミティブ型を表すことができます。
</p>
<pre class="eg">
int
int[]
java.util.Integer
</pre>

<a name=classref></a>
<h3>クラスの参照</h3>
<p>
クラスの参照は次のように行います。
</p>

<div class="box">
<div class="synopsis"><tt>class </tt> <em>class-literal</em></div>
<div class="synopsis">class ( "<em>class-literal</em>" )</div>
</div>

<p>
クラスの参照は、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Class.html"><tt>java.lang.Class</tt></a> オブジェクトで表されます。
</p>

<div class="eg">例:
<pre>
class java.lang.Object --> java.lang.Object class
</pre></div>


<p>
入れ子の内側のクラスは '$' で区切られた名前で表されます。
</p>
<pre class="eg">
class Toplevel$Inner --> Toplevel.Inner class
</pre>


<p>
JDK1.1では、クラスは Pnuts の実行環境を読み込んだクラスローダで検索されます。
J2SE/J2EEでは、システムクラスローダが使われます。ただし、<a href="../apidoc/pnuts/lang/Context.html#setClassLoader(java.lang.ClassLoader)"><tt>Context.setClassLoader()</tt></a> メソッドで <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/ClassLoader.html"><tt>ClassLoader</tt></a> が設定された場合、それがデフォルトのクラスローダになります。
</p>

<a name=expressions></a>
<h2>3. 式</h2>

<a name="arithmetic"></a>
<h3>算術演算子</h3>

<p>
以下の算術演算子は基本的に Java と同じ意味です。
</p>

<table width=300>
<tr align=center>
<td><tt>+</tt></td>
<td><tt>-</tt></td>
<td><tt>*</tt></td>
<td><tt>/</tt></td>
<td><tt>%</tt></td>
</tr>
</table>

<h4>型変換</h4>

<p>
2値演算の型変換表を示します。
</p>

<table border=0 cellspacing=1 cellpadding=3 class=bg3 width=95%>
<tr class=wb>
 <td></td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>Double</td>
 <td>Float</td>
 <td>Long</td>
 <td>Integer</td>
 <td>Character</td>
 <td>Short</td>
 <td>Byte</td>
</tr>
<tr class=wb>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
</tr>
<tr class=wb>
 <td>BigInteger</td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>BigInteger</td>
 <td>BigInteger</td>
 <td>BigInteger</td>
 <td>BigInteger</td>
</tr>
<tr class=wb>
 <td>Double</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>Double</td>
 <td>Double</td>
 <td>Double</td>
 <td>Double</td>
 <td>Double</td>
 <td>Double</td>
 <td>Double</td>
</tr>
<tr class=wb>
 <td>Float</td>
 <td>BigDecimal</td>
 <td>BigDecimal</td>
 <td>Double</td>
 <td>Float</td>
 <td>Float</td>
 <td>Float</td>
 <td>Float</td>
 <td>Float</td>
 <td>Float</td>
</tr>
<tr class=wb>
 <td>Long</td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>Double</td>
 <td>Float</td>
 <td>Long</td>
 <td>Long</td>
 <td>Long</td>
 <td>Long</td>
 <td>Long</td>
</tr>
<tr class=wb>
 <td>Integer</td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>Double</td>
 <td>Float</td>
 <td>Long</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
</tr>
<tr class=wb>
 <td>Character</td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>Double</td>
 <td>Float</td>
 <td>Long</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
</tr>
<tr class=wb>
 <td>Short</td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>Double</td>
 <td>Float</td>
 <td>Long</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
</tr>
<tr class=wb>
 <td>Byte</td>
 <td>BigDecimal</td>
 <td>BigInteger</td>
 <td>Double</td>
 <td>Float</td>
 <td>Long</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
 <td>Integer</td>
</tr>
</table>

<h4>プリ・インクリメント/デクリメント演算子</h4>

<div class="box">
<div class="synopsis"><tt>++</tt> <em>expression</em></div>
<div class="synopsis"><tt>--</tt> <em>expression</em></div>
</div>

<div class="eg">例:
<pre>
a = 0
++a    --> 1
a      --> 1
</pre></div>

<h4>ポスト・インクリメント/デクリメント演算子</h4>

<div class="box">
<div class="synopsis"><em>expression</em> <tt>++</tt></div>
<div class="synopsis"><em>expression</em> <tt>--</tt></div>
</div>

<div class="eg">例:
<pre>
a = 0
a++     --> 0
a       --> 1
a = a++
a       --> 1
</pre></div>


<a name=comparison></a>
<h3>比較演算子</h3>

<table width=300>
<tr align=center>
<td><tt>==</tt></td>
<td><tt>!=</tt></td>
<td><tt>&lt;</tt></td>
<td><tt>&lt;=</tt></td>
<td><tt>&gt;</tt></td>
<td><tt>&gt;=</tt></td>
</tr>
</table>

<p>
両方のパラメータが <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Number.html">Number</a> オブジェクトの場合、数の大きさを比較します。
</p>

<p>
どちらかのパラメータが <a href="../apidoc/pnuts/lang/Numeric.html">Numeric</a> オブジェクトでもう一つのパラメータが Numeric か Number の場合、<tt>Numeric.compareTo()</tt>メソッドで大きさを比較します。
</p>
<p>
両方のパラメータが <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/String.html">String</a> オブジェクトの場合、<tt>String.compareTo()</tt>メソッドで文字列を比較します。
</p>
<div class="eg">例:
<pre>
    "AB" > "A"  --> true
</pre></div>

<p>
両方のパラメータが配列の場合、それらの要素を再帰的に比較します。
この場合は == と != のみが有効です。
</p>
<div class="eg">例:
<pre>
    [1,[2,3]] == [1,[2,3]]  --> true
    [1,2,3] == [1,2]  --> false
</pre></div>

<p>
どちらかのパラメータが<tt>java.lang.Comparable</tt>オブジェクトの場合、<tt>Comparable.compareTo()</tt>メソッドでオブジェクトを比較します。
</p>
<p>
その他の場合の比較演算は <tt>Object.equals()</tt> メソッドでオブジェクトを比較します。
この場合は<tt>==</tt>と <tt>!=</tt> のみが有効です。
</p>

<div class="eg">例:
<pre>
    1 == 1                 --> true
    Object() == Object()   --> false
</pre></div>

<a name=logical></a>
<h3>論理演算子</h3>
<p>
以下の演算子は論理演算子です。
</p>
<p>
<table width=200>
<tr align=center>
<td><tt>&&</tt></td>
<td><tt>||</tt></td>
<td><tt>!</tt></td>
</tr>
</table>

<div class="eg">例:
<pre>
!(1 == 2)  --> true
1 == 1 && 2 == 2 --> true
1 == 1 || 1 == 2 --> true
</pre></div>

<p>
オペランドがbooleanでない場合、<a href="#conversion_to_boolean">booleanへの変換規則</a>で暗黙的にbooleanに変換されます
</p>

<a name=bitwise></a>
<h3>ビット演算子</h3>
<p>
以下の演算子は <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Number.html"><tt>Number</tt></a> オブジェクトに対するものです。
</p>
<p>
<table width=300>
<tr align=center>
<td><tt>&</tt></td>
<td><tt>|</tt></td>
<td><tt>~</tt></td>
<td><tt>^</tt></td>
<td><tt>&gt;&gt;</tt></td>
<td><tt>&lt;&lt;</tt></td>
<td><tt>&lt;&lt;&lt;</tt></td>
</tr>
</table>

<div class="eg">例:
<pre>
1 << 100    --> 1267650600228229401496703205376
</pre></div>

<a name=ternary></a>
<h3>Ternary Operator</h3>
<div class="box">
<div class="synopsis"><em>boolean_expression</em><tt> ? </tt><em>expression</em> : <em>expression</em></div>
</div>

<div class="eg">例:
<pre>
pnuts_version.startsWith("1.1") ? 1 : 0
</pre>
</div>

<a name=assignment></a>
<h3>代入</h3>

<div class="box">
<div class="synopsis"><em>identifier</em> = <em>expression</em></div>
</div>


<h4>演算子と代入</h4>

<p>
<table width=400>
<tr align=center>
<td><tt>*=</tt></td>
<td><tt>/=</tt></td>
<td><tt>+=</tt></td>
<td><tt>-=</tt></td>
<td><tt>%=</tt></td>
<td><tt>&=</tt></td>
</tr>
<tr align=center>
<td><tt>|=</tt></td>
<td><tt>~=</tt></td>
<td><tt>^=</tt></td>
<td><tt>&gt;&gt;=</tt></td>
<td><tt>&lt;&lt;=</tt></td>
<td><tt>&lt;&lt;&lt;=</tt></td>
</tr>
</table>
<p>
これらの演算子は <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Number.html"><tt>Number</tt></a> オブジェクトに対するものです。
</p>

<a name="parallel_assign"></a>
<h4>多重代入</h4>

<div class="box">
<div class="synopsis"><em>identifier1</em> , <em>identifier2</em> , ... = <em>expression</em></div>
</div>
<p>
下記と等価。
<pre class="eg">
<em>identifier1</em> = try {<em>expression</em>[0]} catch (IndexOutOfBoundsException e){}
<em>identifier2</em> = try {<em>expression</em>[1]} catch (IndexOutOfBoundsException e){}
...
null
</pre>

<a name=array></a>
<h3>配列</h3>

<div class="box">
<div class="synopsis">[ <em>expression</em> , ... ]</div>
</div>

<div class="eg">例:
<pre>
[1, 2, 3]
</pre></div>

<p>
配列は互いに異なる型の要素を持つことができます。
</p>

<pre class="eg">
["one", 1, '\u3042', null]
</pre>



<h4>入れ子の配列</h4>
<pre class="eg">
[1, [2, ["yes", "no"], null]]  --> new Object[]{
                                          new Integer(1),
                                          new Object[]{
                                            new Integer(2),
                                            new Object[]{
                                              "yes",
                                              "no"
                                            },
                                            null
                                          }
                                        }
</pre>


<a name=arrayType></a>
<h4>配列型</h4>

<div class="box">
<div class="synopsis"><em>class-object</em> ( [  ] )+</div>
</div>

<div class="eg">例:
<pre>
type1 = class java.lang.Object[]  --> java.lang.Object[] class
type2 = int[][]    --> int[][] type
</pre></div>

<a name=arrayInstance></a>
<h4>配列の生成</h4>

<div class="box">
<div class="synopsis"><em>class-object</em> ( [ <em>integer</em> ] )+</div>
<div class="synopsis"><tt>new</tt> <em>class-literal</em> ( [ <em>integer</em>  ] )+</div>
<div class="synopsis"><tt>new</tt> <em>class-literal</em> ([])+ { <em>element1</em>, ...  }</div>
</div>

<div class="eg">例:
<pre>
    array1 = class java.lang.Object[1]   --> [null]
    array2 = int[3][2]     --> [[0, 0], [0, 0], [0, 0]]
    array3 = new int[]{1, 2, 3}       --> {1, 2, 3}
</pre></div>

<h4>配列の長さ</h4>
<p>
配列オブジェクトは <tt>length</tt> というフィールドを持ち、その配列の要素数を表します。
</p>
<pre class="eg">
[1, 2, 3].length  --> 3
</pre>

<a name="list"></a>
<h4>リスト</h4>
<div class="box">
<div class="synopsis">{ <em>expression</em> , ... }</div>
</div>

<div class="eg">例:
<pre>
{1, 2, 3}
</pre></div>


<a name="arrayIndex"></a>
<h4>配列・リストの要素の参照</h4>

<div class="box">
<div class="synopsis"><em>array</em> [ <em>expression</em> ]</div>
</div>
<p>
<div class="eg">例:
<pre>
a = [1, 2, 3]
a[0]      =--> 1
a[0] = 10
a[0]      =--> 10
</pre></div>

<p>
配列・リストの要素にも代入が可能です。
</p>
<div class="eg">例:
<pre>
a = [1, 2, 3]
a[0] = 100
a       =--> [100, 2, 3]
</pre></div>


<p>
<em>expression</em>の値が負の整数 <em>idx</em>の場合で、配列の大きさが <em>len</em>だとすると、
<tt>a[</tt><em>idx</em><tt>]</tt> は <tt>a[</tt><em>idx</em><tt> + </tt><em>len</em><tt>]</tt>と解釈されます。

<div class="eg">例：
<pre>
a = [1, 2, 3]
a[-1] => 3
a[-2] => 2
a[-3] => 1
a[-4] => error
</pre></div>


<h4>部分配列・部分リスト</h4>


<div class="box">
<div class="synopsis"><em>array</em> [ <em>startIndex</em> ..]</div>
<div class="synopsis"><em>array</em> [ <em>startIndex</em> .. <em>endIndex</em> ]</div>
</div>

<p>
<em>startIndex</em>から<em>endIndex</em>までの範囲を取り出した部分配列を求めます。
<em>startIndex</em>から<em>endIndex</em>までの範囲が、配列のインデックスの範囲から外れて
いる場合や、<em>startIndex</em>が<em>endIndex</em>より大きい場合は、空の配列を返します。
</p>

<pre class="eg">
foo = [1, 2, 3]
foo[1..] --> [2, 3]
foo[1, 1] --> [2]
</pre>

<h4>部分文字列</h4>


<div class="box">
<div class="synopsis"><em>string</em> [ <em>startIndex</em> ..]</div>
<div class="synopsis"><em>string</em> [ <em>startIndex</em> .. <em>endIndex</em> ]</div>
</div>

<p>
<em>startIndex</em>から<em>endIndex</em>までの範囲を取り出した部分文字列を求めます。
<em>startIndex</em>から<em>endIndex</em>までの範囲が、文字列のインデックスの範囲から外れて
いる場合や、<em>startIndex</em>が<em>endIndex</em>より大きい場合は、空の文字列を返します。
</p>

<pre class="eg">
foo = "123"
foo[1..]   --> foo.substring(1)  --> "23"
foo[1..1]  --> foo.sunstring(1, 2) --> "2"
</pre>

<h4>文字列中の文字</h4>

<div class="box">
<div class="synopsis"><em>string</em> [ <em>index</em> ]</div>
</div>

<pre class="eg">
foo = "123"
foo[1]   -->   foo.charAt(1)    -->  '2'
</pre>

<a name="map"></a>
<h4>Map式</h4>

<div class="box">
<div class="synopsis">{ <em>key</em> =&gt; <em>value</em> , ...}</div>
</div>
<p>
1つ以上の（キー=>値）のマッピングがこの式に与えられると、そのマッピングを含む<tt>java.util.HashMap</tt>オブジェクトが作られて返されます。
</p>
<pre class="eg">
{ "name"=>"Sae",  "age" => 1 }
</pre>

<a name="map_elements"></a>
<h4>Mapの要素</h4>

<div class="box">
<div class="synopsis"><em>map</em> [ <em>key</em> ]</div>
<div class="synopsis"><em>map</em> [ <em>key</em> ] = <em>value</em></div>
</div>

<P>Java2の環境では、<CODE>java.util.Map</CODE>オブジェクトのキーをブラケット[]で囲みと、対応する値にアクセスできます。
</p>
<pre class="eg">
foo = map()
foo["age"] = 24
foo["age"] --> 24
</pre>

<a name="selection"></a>
<h4>要素の抽出</h4>

<div class="box">
<div class="synopsis"><em>target</em> [ <em>predicate</em>(elem) ]</div>
<div class="synopsis"><em>target</em> [ <em>expression</em> ]</div>
</div>

<p>
<em>target</em>が、配列、Collection, ジェネレータのいずれかで、<em>predicate</em>が 1引数の関数の場合には、<em>target</em>の要素のうち<em>predicate</em>がtrueを返す要素を生成するジェネレータを返します。
</p>
<div class="eg">
<pre>
x = list([1,2,3])
for (i : x[function (x) x % 2 == 0]) {
   println(i)
}
</pre></div>

<p>
<em>expression</em>が 論理式の場合には、<em>expression</em>は1引数の関数に変換され、同様の処理を行ないます。
<em>expression</em>が、比較演算子をもちいた二項論理式(<em>lval</em> <em>compare_op</em> <em>rval</em>)の場合、<em>lval</em>のいちばん左の識別子は、<em>target</em>の要素のフィールドとして解釈されます。

<div class="eg">
<pre>
x = list()
import java.awt.Button
for (i : 1..10) x.add(Button())

x[name == "button0"]

 -->

x[function (i) i.name == "button0"]
</pre></div>

<div class="eg">
<pre>
x[name == "button0" || name == "button1"]

 -->

x[function (i) (i.name == "button0" || i.name == "button1")]
</pre></div>


<p>
また、<em>expression</em>が ! <em>val</em>という単項論理式の場合も、
<em>val</em>のいちばん左の識別子は、<em>target</em>の要素のフィールドとして解釈されます。
</p>

<div class="eg">
<pre>
x[!visible]

  -->

x[function (i) !i.visible]
</pre></div>

<a name="concatenation"></a>
<h3><tt>+ </tt>演算子（数値以外）</h3>

<h4>配列/Collections</h4>

<div class="box">
<div class="synopsis">
<div><em>array1</em> + <em>array2</em></div>
<div><em>array</em> + <em>collection</em></div>
<div><em>collection</em> + <em>array</em></div>
<div><em>collection1</em> + <em>collection2</em></div>
</div>
</div>

<p>
２つのオブジェクトを連結します。
</p>

<div class="eg">例：
<pre>
[1, 2, 3] + [4, 5, 6]     ---> [1, 2, 3, 4, 5, 6]
</pre>
</div>

<p>
結果の配列(またはCollection)は、1番目の配列と同じ型になります。
</p>

<pre class="eg">
int[0] + [1, 2, 3]     ---> [1, 2, 3]
</pre>

<p>
<em>collection1</em> と <em>collection2</em> が Setオブジェクトの場合、
結果は２つの集合の和集合になります。
</p>

<h4>Map</h4>

<div class="box">
<div class="synopsis"><em>map</em> + <em>map</em></div>
</div>

<div class="eg">例：
<pre>
{1=>2, 2=>3} + {2=>4, 3=>5}    --> {1=>2, 2=>4, 3=>5}
</pre>
</div>

<h4>文字列</h4>

<div class="box">
<div class="synopsis"><em>string</em> + <em>string</em></div>
</div>

<pre class="eg">
foo = "ABC"
bar = "DEF"
foo + bar      ---> "ABCDEF"
</pre>

<h3><tt>- </tt>演算子（数値以外）</h3>

<div class="box">
<div class="synopsis">
<div><em>array1</em> - <em>array2</em></div>
<div><em>array</em> - <em>collection</em></div>
<div><em>collection</em> - <em>array</em></div>
<div><em>collection1</em> - <em>collection2</em></div>
</div>
</div>
<p>
最初のオブジェクトの要素のうち、２番目のオブジェクトに含まれないものを
含むCollectionまたは配列を返します。
<p>
結果の配列(またはCollection)は、1番目の配列と同じ型になります。
</p>

<pre class="eg">
[1,1,1,2] - [1]   ---> [2]
[1,1,1,2] - [2]   ---> [1,1,1]
[1,1,1,2] - [1,3]   ---> [2]
</pre>

<h3><tt>* </tt>演算子 （Set オブジェクト）</h3>

<div class="box">
<div class="synopsis">
<div><em>set1</em> * <em>set2</em></div>
</div>
</div>
<p>
２つの集合の積集合を返します。

<pre class="eg">
set([1,2]) * set([1,3])   ---> [1]
</pre>

<a name=concatenation></a>
<h3>連結演算子</h3>

<h4>配列の連結</h4>

<div class="box">
<div class="synopsis"><em>array</em> + <em>array</em></div>
</div>

<p>
2つの配列を連結します。
</p>
<div class="eg">例:
<pre>
[1, 2, 3] + [4, 5, 6]     =--> [1, 2, 3, 4, 5, 6]
</pre></div>
<p>
結果の配列は、1番目の配列と同じ型になります。したがって、2番目の配列の要素は1番目の配列の要素の型にマッチしなければなりません。
</p>

<a name=stringConcatenation></a>
<h4>文字列の連結</h4>

<div class="box">
<div class="synopsis"><em>string</em> + <em>string</em></div>
</div>

<pre class="eg">
foo = "ABC"
bar = "DEF"
foo + bar   --> "ABCDEF"
</pre>

<a name="new"></a>
<a name="instanceCreation"></a>
<h3>インスタンスの生成</h3>

<div class="box">
<div class="synopsis"><em>class-object</em> ( <em>expression</em>, ... )</div>
<div class="synopsis"><tt>new</tt> <em>class-literal</em> ( <em>expression</em>, ... )</div>
</div>

<div class="eg">例:
<pre>
class java.awt.Point(10, 20)

Point = class java.awt.Point
Point(10, 20)

import java.awt.Point
new Point(10, 20)
</pre></div>

<a name="inline_classdef"></a>
<h3>インライン・クラス定義</h3>

<div class="box">
<div class="synopsis"><tt>class</tt> <em>class_literal</em> [ <tt>extends</tt> <em>superclass</em> ]
[ <tt>implements</tt> <em>interface</em>... ] </div>
<div class="synopsis"><tt>{</tt></div>
(
<div class="synopsis2">[ <em>type</em> ] <em>fieldName</em> [ = <em>initialValue</em> ] </div>
|
<div class="synopsis2">[ <em>type</em> ] <em>methodName</em> ([<em>type</em>] <em>var</em>...) { .. } </div>
)*
<div class="synopsis">}</div>
</div>

<div class="eg">例：
<pre>
class Person {
  int age; String name
  Person(age, name){
     this.age=age; this.name=name
  }
}
</pre>
</div>

<a href="#classdef">「クラス定義」</a>の章を参照。


<a name="subclass"></a>
<h3>サブクラスの生成</h3>

<div class="box">
<div class="synopsis"><tt>new</tt> <em>class-literal</em> ( <em>expression</em>, ... ) {</div>
<div class="synopsis2">[ <em>type</em> ] <em>identifier</em> ( [ <em>type</em> ] <em>identifier</em> ... ) {</div>
<div class="synopsis2">... }</div>
<div class="synopsis">... }</div>
</div>

<p>
<em>new式</em>の後に{}で囲まれた0個以上のメソッド定義がくる場合、そのクラスのサブクラスが動的に定義され、インスタンスが生成されます。
</p>
<div class="eg">例
<pre>
import java.awt.event.*
new WindowAdapter(){
  windowClosing(e){
    e.source.dispose()
  }
}
</pre>
</div>
<p>
特別な変数'<tt>this</tt>' がメソッド呼び出しのターゲットとして使われると、Java言語と同様、そのクラスのインスタンスメソッドが呼び出されます。
</p>
<div class="eg">例
<pre>
x = new Object(){
  test(){
    this.toString()
  }
}
x.test()
</pre>
</div>

<p>
特別な変数'<tt>super</tt>' がメソッド呼び出しのターゲットとして使われると、Java言語と同様、スーパークラスのそのメソッドが呼び出されます。
</p>
<div class="eg">例
<pre>
x = new Object(){
  toString(){
    "blah " + super.toString()
  }
}
x.toString()
</pre>
</div>
<p>
メソッド定義の中からは、通常の入れ子の関数と同様、レキシカルスコープにアクセスできます。
</p>
<div class="eg">例
<pre>
function test(n){
 x = new Object(){
       test(){
          println(n)
       }
    }
 x.test()
}
test(100)
</pre>
</div>


<a name="beandef"></a>
<h3>Java Beansの生成</h3>



<div class="box">
<div class="synopsis"><em>class_literal</em> <tt>{</tt> </div>
<div class="synopsis2"><em>fieldName</em> <tt>:</tt> <em>expression</em> or </div>
<div class="synopsis2"><em>fieldName</em> <tt>::</tt> <em>expression</em></div>
<div class="synopsis2">... </div>
<div class="synopsis"><tt>}</tt></div>
</div>
<div class="eg">例
<pre>
btn = java.awt.Button {
        labal : "OK"
      }
</pre>
</div>

これは以下のように解釈されます。
<div class="eg">
<pre>
btn = new java.awt.Button()
btn.labal = "OK"
btn
</pre>
</div>
<p>
（以下、実験的）特別なセパレータ<tt>::</tt>が用いられる場合、<em>expression</em> に現れるBean Propertyが変更されるたびに、
その新しい値を使って<em>fieldName</em>が再計算されます。
</p>
<div class="eg">例：
<pre>
import javax.swing.*

f = JFrame();
f.name = "foo"
btn = JButton {
  label :: f.name
}
btn.label --> "foo"

f.name = "bar"
btn.label --> "bar"
</pre>
</div>
<p>
また、<tt>::</tt>の後ろの式がただ一つのBean Property式である場合、値の反映は双方向になります。
</p>

<div class="eg">例：
<pre>
btn.label = "zzz"
f.name --->  "zzz"
</pre>
</div>
<p>
これらはJavaBeansのPropertyChangeListener/PropertyChangeEventの仕組みを使って実現されます。
</p>

<a name="instanceof"></a>
<h3>instanceof 演算子</h3>

<div class="box">
<div class="synopsis"><em>object</em> <tt>instanceof</tt> <em>type</em></div>
</div>

<p>
<em>object</em>が<em>type</em>のインスタンスかどうかを判定して、
true または false を返します。
</p>

<div class="eg">例:
<pre>
"hello" instanceof String     --> true
</pre></div>

<a name="cast"></a>
<h3>キャスト</h3>

<div class="box">
<div class="synopsis">( <em>type</em> ) <em>expression</em></div>
</div>

<p>
<em>type</em> が基本型あるいは基本配列型の場合、<em>expression</em>の値は適切な型へ変換されます。
</p>

<p>
<em>expression</em>の値が <em>type</em>のインスタンスの場合は、変換されません。
</p>

<p>
<em>expression</em> の値が <em>type</em> に変換できない場合は <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/ClassCastException.html"><tt>ClassCastException</tt></a> が送出されます。
</p>

<p>
型のキャストが、<a href="#instanceCreation">コンストラクタ</a>、
<a href="#instanceMethod">インスタンスメソッド</a>、または <a
href="#staticMethod">スタティック・メソッド</a> のパラメータになる場合は、
その型の情報を使ってメソッドやコンストラクタを選択します。
</p>

<a name=predefined></a>

<h3>定義済みの変数</h3>

<blockquote>
<table width=400>
<tr align=center>
<td><tt>int</tt></td>
<td><tt>byte</tt></td>
<td><tt>short</tt></td>
<td><tt>char</tt></td>
<td><tt>long</tt></td>
<td><tt>float</tt></td>
<td><tt>double</tt></td>
<td><tt>boolean</tt></td>
</tr>
</table>
</blockquote>

これらの変数は、対応するClassオブジェクトと定義されます。

<a name=primitive></a>
<h3>プリミティブ型データの型変換</h3>

<p>
プリミティブ型の Class オブジェクトは、対応するクラスへの変換を行う関数としても利用できます。 
</p>

<div class="box">
<div class="synopsis"><em>primitive</em> ( <em>expression</em> )</div>
</div>

<p>
<em>expression</em>が文字列の場合は、左右の空白があればそれを削除し、対応する数に変換します。この場合10進数が仮定されます。
<em>expression</em>が Number の場合は、指定された型に変換されます。
<em>expression</em>が文字の場合は、<tt>int()</tt>, <tt>byte()</tt>, <tt>short()</tt> は文字コードを返します。
文字コードがその型が表すことができる範囲を越える場合はエラーになります。
</p>
<div class="eg">例:
<pre>
int(" 1 ")    -->  1
int('1')      -->  49
</pre></div>

<p>
<em>primitive</em>が Character で、<em>expression</em>を評価した結果の整数が 0〜0xffff の範囲である場合、そのコードポイントの文字を返します。範囲外の場合はエラーになります。
</p>
<div class="eg">例:
<pre>
char(65)    -->  'A'
</pre></div>

<a name=conversion_to_boolean></a>
<h3>booleanへの変換</h3>

<em>primitive</em>がbooleanの場合、引数は次の規則を使ってboolean型の値に変換されます。

<ul>
<li>引数がBooleanオブジェクトまたはboolean型の値の場合、そのまま返します。
<li>引数がNumberオブジェクトの場合、ゼロのでない場合にtrueを返します。
<li>引数がStringオブジェクトの場合、引数が空文字でない場合にtrueを返します。
<li>引数が上記以外のオブジェクトの場合、それがnullでない場合に true を返します。
</ul>

<div class="eg">例：
<pre>
boolean(true)      ---> true
boolean(false)     ---> false
boolean(-1)        ---> true
boolean(0)         ---> false
boolean("non-empty")  ---> true
boolean("")        ---> false
boolean("false")   ---> true
boolean(new Object())  ---> true
boolean(null)      ---> false
</pre>
</div>

<div class="box">
<div class="synopsis"><em>primitive</em> ( <em>string</em> {, <em>radix</em> })</div>
</div>

<p>
int, byte, short, longについては、文字列とradixを指定して文字列から整数への変換を行なうことができます。
</p>

<div class="eg">例:
<pre>
int("20", 16)    --> 32
long("cafebabe", 16)    --> 3405691582
</pre>
</div>

<a name=instanceField></a>
<h3>インスタンス・フィールド</h3>

<div class="box">
<div class="synopsis"><em>expression</em> . <em>identifier</em></div>
</div>

<p>
インスタンス・フィールドへのアクセスは、基本的にJava Beansのプロパティへのアクセスになります。ただし、<em>expression</em>が特定のクラスの場合には独自のふるまいになります。
</p>
</p>
<dl>
<dt>java.util.Map
<dd><em>identifier</em>をキーとしてその値を返す
<dt>pnuts.lang.Context
<dd><a href="api.html">Pnuts API</a>を参照
<dt>pnuts.lang.Property
<dd><a href="api.html">Pnuts API</a>を参照
<dt>上記以外
<dd>Java Beansのプロパティへのアクセス
</dl>

<div class="eg">例:
<pre>
import("java.awt.Button")
btn = Button("hello")
btn.label    --> "hello"
</pre></div>
<p>
インスタンス・フィールドへのアクセスは、Pnuts APIによって柔軟にカスタマイズすることができます。<a href="configuration.html">「Java APIアクセスのカスタマイズ」</a>を参照。
</p>

<a name=staticField></a>
<h3>スタティック・フィールド</h3>

<div class="box">
<div class="synopsis"><em>class-object</em> <tt>::</tt> <em>identifier</em></div>
</div>

<p>
参照できるのは public のフィールドのみです。
</p>

<div class="eg">例:
<pre>
class java.awt.Color::blue
</pre></div>

<p>
代入できるのは public のフィールドのみです。
</p>


<a name="instanceMethod"></a>
<h3>インスタンス・メソッドの呼び出し</h3>

<div class="box">
<div class="synopsis"><em>expression</em> . <em>identifier</em> (  <em>expression</em> , ...  )</div>
</div>

<div class="eg">例:
<pre>
"ABC".length()  --> 3
"ABC".getClass() --> java.lang.String class
</pre></div>

<a name="staticMethod"></a>
<h3>スタティック・メソッドの呼び出し</h3>

<div class="box">
<div class="synopsis"><em>class-object</em> <tt>::</tt> <em>identifier</em> (  <em>expression</em> , ...  )</div>
</div>


<div class="eg">例:
<pre>
class java.lang.System::gc()

sys = class java.lang.System
sys::gc()
</pre></div>


<a name=typeMapping></a>
<h3>型の対応と変換</h3>

<p>
int, long 等の Java のプリミティブ型は <a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/Number.html">Number</a> クラスのサブクラスでラップされます。
Java のメソッドがプリミティブ型の値を返す場合、スクリプト側ではラッパーオブジェ
クトを受け取ります。Java のメソッドがプリミティブ型のパラメータを受け取る場合、
スクリプト側の実引数はそのシグネチャに合致するように変換されます。
</p>

<div class="eg">例:
<pre>
str = "ABCDE"
str.charAt(1)  --> 'B'
</pre></div>

<p>
int[], byte[] 等の Java の配列型は、Pnuts でもそのまま扱われます。
Java のメソッドが配列のパラメータを受取り型変換が必要であれば、
メソッドのシグネチャに合致する新しい配列が生成され、そのメソッドに
適用されます。
</p>


<div class="eg">例:
<pre>
array = "Hello".toCharArray()   --> ['H','e','l','l','o']
array.getClass()                --> char[] type
String(['H','e','l','l','o'])   --> "Hello"
</pre></div>


<a name=conditional></a>
<h3>条件分岐</h3>

<a name=if></a>
<a name=else></a>
<h4>if-else</h4>

<div class="box">
<div class="synopsis"><b>if</b> ( <em>boolean expression</em> )  <em>expression-block</em></div>
<div class="synopsis"><b>else if</b> ( <em>boolean expression</em> )  <em>expression-block</em></div>
<div class="synopsis">...</div>
<div class="synopsis"><b>else</b> <em>expression-block</em></div>
</div>


<pre class="eg">
foo = [1, 2, 3]
if (foo.length > 5){
   1
} else if (foo.length > 4){
   2
} else {
   3
}     --> 3

value = if (foo.length > 3) 1 else 2
value  --> 2
</pre>

<a name=switch></a>
<a name=case></a>
<a name=default></a>
<h4>Switch</h4>

<div class="box">
<div class="synopsis"><b>switch</b> ( <em>expression</em> ) {</div>
<div class="synopsis">case <em>expression</em> : <em>expression-block</em></div>
<div class="synopsis">...</div>
<div class="synopsis">default : <em>expression-block</em></div>
<div class="synopsis">}</div>
</div>

<p>
<tt>equals()</tt> メソッドで比較を行います。
</p>

<a name=break></a>
<h4>break</h4>
<div class="box">
<div class="synopsis"><b>break</b> [ <em>expression</em> ]</div>
</div>

<p>
パラメータ<em>expression</em>を指定しない場合は、"break null" と等価です。
</p>


<a name=while></a>
<h4>While</h4>

<div class="box">
<div class="synopsis"><b>while</b> ( <em>boolean expression</em> )  <em>expression-block</em></div>
</div>

<pre class="eg">
while (sum > 0){
   sum = sum - 1
}
</pre>

<a name=dowhile></a>
<h4>do .. while</h4>

<div class="box">
<div class="synopsis"><b>do</b> { <em>expression-block</em> } <b>while</b> ( <em>boolean expression</em> )  </div>
</div>

<pre class="eg">
x = 0
do {
  println(x++)
} while (i < 10)
</pre>

<a name="for"></a>
<h4>For</h4>

<div class="box">
<b>for</b> ( [ <em>identifier</em> = <em>expression</em> , ... ] ; [ <em>expression</em> ] ; [ <em>expression</em> , ... ] )  <em>expression-block</em></div>
</div>

<pre class="eg">
j = 0
for (i : 0..4){
   j = j + i
}

for (; j > 0; j--){
   println(j)
}
</pre>

<div class="box">
<div><b>for</b> ( <em>identifier</em> : <em>integerStart</em> .. <em>integerEnd</em> )  <em>expression-block</em></div>
<div><b>for</b> ( <em>identifier</em> : <em>expression</em> )  <em>expression-block</em></div>
</div>
<p>
最初の形式の場合、<em>integerStart</em>から<em>integerEnd</em>までの整数を1つづつ変化させたものを<em>identifier</em>に代入して<em>expression-block</em>を実行します。
</p>
<p>
2番目の形式の場合、<em>expression</em>の型に応じて適当なメソッド呼び出しを行なうことで、<em>expression</em>の要素を１つずつ取り出したものを<em>identifier</em>に代入して<em>expression-block</em>を実行します。<em>expression</em>には、次のような型のオブジェクトが指定できます。
</p>

<ul>
<li>java.util.Enumeration
<li>java.util.Iterator
<li>java.util.Collection
<li>java.util.Map
<li>Object[] or primitive array
<li>java.lang.String
<li>java.lang.CharSequence (1.4+)
<li>pnuts.lang.Generator
</ul>

<pre class="eg">
for (i : 1..3) print(i)    --> 123

for (i : 3..1) print(i)    --> 321

for (i : [1, 2, 3]) print(i)  --> 123
</pre>
<p>
<a name="multivar_for"></a>
<div class="box">
<div><b>for</b> ( <em>identifier_1</em> , ..., <em>identifier_N</em> : <em>expression</em> )  <em>expression-block</em></div>
</div>
<p>
2番目の形式のバリエーションとして、変数が複数指定されることがあります。その場合、下記の式と等価です。
</p>
<pre class="eg">
for (tmp : <em>expression</em>) {
  <em>identifier_1</em> = try { tmp[0]} catch (IndexOutOfBoundsException e){}
  ...
  <em>identifier_N</em> = try { tmp[N-1]} catch (IndexOutOfBoundsException e){}

  <em>expression-block</em>
}
</pre>

<a name=foreach></a>
<h4>Foreach</h4>

<div class="box">
<div class="synopsis"><b>foreach</b> <em>identifier</em> <em>array</em>  <em>expression-block</em></div>
<div class="synopsis"><b>foreach</b> <em>identifier</em> ( <em>java.util.Enumeration</em> )  <em>expression-block</em></div>
<div class="synopsis"><b>foreach</b> <em>identifier</em> (<em>java.util.Iterator</em> )  <em>expression-block</em></div>
<div class="synopsis"><b>foreach</b> <em>identifier</em> (<em>java.util.Collection</em> )  <em>expression-block</em></div>
</div>

<p>
<tt>foreach i (expr)</tt>という式は、<tt>for(i:expr)</tt>同じ意味です。
</p>

<pre class="eg">
sum = 0
foreach i [1, 2, 3] {
    sum = sum + i
}
sum  --> 6

sum = 0
vec = class java.util.Vector()
vec.addElement(1)
vec.addElement(2)
vec.addElement(3)
foreach i (vec.elements()) {
    sum = sum + i
}
sum  --> 6
</pre>

<a name=continue></a>
<h4>continue</h4>
<div class="box">
<div class="synopsis"><b>continue</b></div>
</div>
<p>
<pre class="eg">
for (i : 0..9){
   if (i > 2){
      continue
   }
   println(i)
}
</pre>

<a name=return></a>
<h4>return</h4>
<div class="box">
<div class="synopsis"><b>return</b> [ <em>expression</em> ]</div>
</div>
<p>
関数の中で<tt>return</tt> した場合はその関数が<em>expression</em> の値を返します。
トップレベルで<tt>return</tt> を評価した場合は、そのインタプリタセッションが
<em>expression</em>の値を返します。この場合<a href="#quit"><tt>quit(</tt><em>expressoin</em><tt>)</tt></a>と同じはたらきをします。
</p>
<p>
パラメータ<em>expression</em>を指定しない場合は、"return null" と等価です。
</p>

<a name="try"></a>
<h4>try/catch/finally</h4>

<div class="box">
<div class="synopsis"><b>try</b> { <em>expression-block-1</em> }</div>
<div class="synopsis2">[ <b>catch</b> (<em>class-literal</em> <em>var</em>){ <em>expression-block-2</em> } ]*</div>
<div class="synopsis2">[ <b>finally</b> { <em>expression-block-3</em> } ]</div>
</div>

<p>
<pre class="eg">
try {
   throw ("blah")
} catch (java.io.IOException e1){
   println(1)
} catch (Exception e2){
   println(2)
} finally {
   println(3)
}
</pre>

<a name=function></a>
<h3>関数</h3>

<h4>関数定義</h4>

<div class="box">
<div class="synopsis"><b>function</b> [ <em>identifier</em> ] ( <em>identifier</em>, ...) <em>expression-block</em></div>
<div class="synopsis"><b>function</b> [ <em>identifier</em> ] ( <em>identifier</em>, ..., <em>identifier</em> [ ] ) <em>expression-block</em></div>
</div>

<p>
<em>identifier</em> が指定された場合、その名前の関数が定義されます。その場合、関数は名前と引数の数で識別されます。
</p>
<p>
<em>identifier</em> が省略された場合、ユニークな識別子が自動的に生成されます。
</p>

<div class="eg">例:
<pre>
f = function (e) e.getSource().dispose()
</pre></div>

<a name="closure"></a>
<h4>匿名関数の短縮形</h4>

<div class="box">
<div class="synopsis"><b><tt>{</tt></b> <em>parameter-list</em> <b><tt>-&gt;</tt></b> <em>expression-block</em> <b><tt>}</tt></b></div>
</div>

<div class="eg">
<pre>
{a,b -> a + b}      // function (a,b) a + b　と同じ
</pre>
</div>

<a name="vararg"></a>
<h4>可変長引数</h4>

<p>
関数のパラメータが一つ以上あって、最後に "[]"がついている場合、その関数は可変長パラメータを持つことになります。
</p>

<div class="eg">例：
<pre>
function f(args[]) args
f()             ---> []
f(1)            ---> [1]
f(1,2,3)        ---> [1, 2, 3]

function g(a,b[]) b
g(1)          ---> []
g(1,2)        ---> [2]
g(1,2,3)      ---> [2,3]
</pre>
</div>
<p>
名前のある関数に対して、可変長パラメータを持てる関数は一つだけ定義できます。
</p>
<div class="eg">例：
<pre>
function f(args[]) args
..
function f(a,b,c[]) c   // f(args[])は呼べなくなる
f()             --> error
f(1,2)          --> []
f(1,2,3)        --> [3]
f(1,2,3,4)      --> [3,4]
</pre> 
</div>

<p>
ある関数が呼ばれたとき、パラメータの数の一致する関数が定義されている場合は、たとえ可変長パラメータの関数が定義されていたとしても、その関数が呼ばれます。</p>

<div class="eg">例：
<pre>
function f(args[]) args

function f(arg)  arg
f(1)            ---> 1       // f(arg) が優先
f(1,2,3)        ---> [1, 2, 3]
</pre></div>


<a name="function_scope"></a>
<h4>関数定義のスコープ規則</h4>

<p>
単一スコープで、名前が同じで引数の数だけ違う関数を複数定義した場合、一つの関数オブジェクトに結合されます。
</p>

<div class="eg">
<pre>
function f() 1
function f(a) a

x = f
x() / ---> 1
x(100) / ---> 100
</pre>
</div>
<p>
ローカルスコープ内の入れ子関係にある複数スコープで、名前が同じで引数の数だけ違う関数を複数定義した場合、それらの関数は結合されず、
内側のスコープで外側のスコープの関数が再定義されます。
</p>
<div class="eg">
<pre>
function scope1(){
   function f() 1

   function scope2(){
      function f(a) a
      f() // --> 1
   }

   scope2()
   f()  // --> 1
   f(100)  // --> error
}
</pre>
</div>

<p>
トップレベルに定義した関数と同じ名前でローカルスコープに関数が定義される場合、ローカルスコープでの関数呼び出しは、
変数の参照と同様、ローカルスコープ -> トップレベルの順で呼び出し可能な関数を探索します。
ローカルスコープで定義される関数はトップレベルに影響を与えることはありません。
</p>
<div class="eg">
<pre>
function f() 1
function g(){
  function f(a) a
  f(100)  // --> 100
  f()  // --> 1
}

f()      // --> 1
f(100)   // --> not found
</pre>
</div>


<p>
参照可能なパッケージ(モジュール)の関数を、違う引数でトップレベルに定義しなおすことができます。この場合は、
元の関数オブジェクトに新しい定義が結合されるのではなく、そのパッケージ内だけで関数が再定義されることになります。
</p>

<div class="eg">
<pre>
use("pnuts.lib")
function string(a, b){
   string(b)
}
</pre>
</div>

参照可能なパッケージ(モジュール)の関数は、ローカルスコープでは、ローカルスコープの同名関数に隠されます。

<div class="eg">
<pre>
function g(){
   function string(a, b) string(a) // --> no such function: string (1)
   string(1, 2)
}
</pre>
</div>

別パッケージの関数がローカルスコープの同名関数で隠されないようにするには、
別パッケージの関数をいったんローカルスコープの変数に代入します。

<div class="eg">
<pre>
function g(){
   string = string
   function string(a, b) string(a + b)
   string(1, 2)
}
</pre>
</div>

<h4>関数呼び出し</h4>

<div class="box">
<div class="synopsis"><em>function</em> ( <em>expression</em>, ... )</div>
</div>

<p>
関数を呼び出すと、仮引数を実引数に置き換えて<em>関数の定義部分</em>が実行されます。
</p>

<a name="package"></a>
<h3>パッケージ</h3>

<div class="box">
<div class="synopsis"><em>packageName</em> <tt>::</tt> <em>variable</em></div>
<div class="synopsis"><em>packageName</em> <tt>::</tt> <em>function</em> ( ... )</div>
</div>

<p>
<em>packageName</em>の中の変数 <em>variable</em> は、そのパッケージ名が正当なPnutsの識別子であれば
<em>packageName</em><tt>::</tt> <em>variable</em> で参照できます。
</p>

<a name="generator"></a>
<h3>ジェネレータ</h3>

<a name=yield></a>
<h4>yield</h4>

<div class="box">
<div class="synopsis"><b>yield</b> <em>expression</em> </div>
</div>

<p>
1つ以上'yield'式を含む関数は、呼び出されたときに、関数定義を実行せず、ジェネレータを返します。
ジェネレータの中でyield される値は、for/foreach文によって１つずつ取りだされます。
</p>

<pre class="eg">
function integerGenerator(min, max){
   for (i: min..max) yield i
}

g = integerGenerator(0, 3)    --> generator

for (i : g){
    println(i)
}
 =--> 0
      1
      2
      3
</pre>

<h4>部分シーケンス・ジェネレータ</h4>

<div class="box">
<div class="synopsis"><em>generator</em> [ <em>startIndex</em> ..]</div>
<div class="synopsis"><em>generator</em> [ <em>startIndex</em> .. <em>endIndex</em> ]</div>
</div>
<p>
部分シーケンス・ジェネレータは、<em>generator</em>が生成するオブジェクトのうち、<em>startIndex</em>番目から(<em>endIndex</em>が指定された場合は)<em>endIndex</em>番目のものを生成するジェネレータを返します。
</p>
<pre class="eg">
function g(n){
  for(i:0..n) yield i
}
x = g(100)
for (i: x[90..]) println(i)
</pre>

<a name="composite_generator"></a>
<h4>ジェネレータに対する(+)演算</h4>

<div class="box">
<div class="synopsis"><em>generator1</em> + <em>generator2</em></div>
</div>
<p>
２つのジェネレータに対する<tt>+</tt>演算は、<em>generator1</em> と <em>generator2</em> を順に使ってオブジェクトを生成する新たなジェネレータを返します。
</p>
<pre class="eg">
x = range(1, 10)
even = x[function (x) x % 2 == 0]
odd = x[function (x) x % 2 != 0]
printAll(even + odd)
</pre>

<h4>ジェネレータに対するインデックス・アクセス</h4>

<div class="box">
<div class="synopsis"><em>generator</em> [ int <em>N</em> ]</div>
<div class="synopsis"><em>generator</em> [ <em>predicate(elem)</em> ]</div>
<div class="synopsis"><em>generator</em> [ <em>expression</em> ]</div>
</div>

<p>
整数が指定された場合は、ジェネレータが生成するN番目のオブジェクトを求めます。
生成されるオブジェクトがN個未満の場合は<tt>null</tt>を返します。
</p>

<pre>
function range(start, end){
  for(i:start..end) yield i
}
x = range(1, 100)
x[90]                  ---> 90
x[200]                 ---> null
</pre>

<p>
1引数の関数<em>predicate</em>が指定された場合は、生成される各要素のうち、関数がtrueとなる要素のみを生成するジェネレータを返します。
</p>

<pre>
function range(start, end){
  for(i:start..end) yield i
}
x = range(1, 100)
list(x[function (x) x < 4])     ---> 1,2,3
</pre>

<p>
<em>expression</em>が 論理式の場合には、<em>expression</em>は1引数の関数に変換され、同様の処理を行ないます。
<em>expression</em>が、比較演算子をもちいた二項論理式(<em>lval</em> <em>compare_op</em> <em>rval</em>)の場合、<em>lval</em>のいちばん左の識別子は、<em>generator</em>から生成される要素のフィールドとして解釈されます。
<a href="#selection">「要素の抽出」</a>を参照。
</p>

<pre>
import java.awt.Button
function buttons(n) {for (i : 1..n) yield(Button())}
x = buttons(10)
printAll(x[name == "button0"])
</pre>


<div class="box">
<div class="synopsis"><em>generator</em> . <em>identifier</em></div>
</div>

<p>
ジェネレータに対するインスタンス・フィールドへのREADアクセスは、生成される各要素に対してインスタンス・フィールドを参照した結果をそれぞれ生成するジェネレータを返します。<a href=#instanceField>「インスタンス・フィールド」</a>を参照。
</p>
<pre>
import java.awt.Button
function buttons(n) {for (i : 1..n) yield(Button())}
x = buttons(10)
printAll(x.name)
</pre>
<p>
ジェネレータに対するインスタンス・フィールドへのWRITEアクセスは、生成される各要素に対してインスタンス・フィールドを変更します。
</p>

<pre>
import java.awt.Button
buttons = [Button(),Button(),Button()]
function generator(elements) for (i:elements) yield i
generator(buttons).name = "new name"
printAll(generator(buttons).name)
</pre>


<a name="classdef"></a>
<h2>4. クラス定義</h2>

<div class="box">
<div class="synopsis"><tt>class</tt> <em>class_literal</em> [ <tt>extends</tt> <em>superclass</em> ]
[ <tt>implements</tt> <em>interface</em>... ] </div>
<div class="synopsis"><tt>{</tt></div>
(
<div class="synopsis2"><em>type</em> <em>fieldName</em> [ = <em>initialValue</em> ] </div>
|
<div class="synopsis2"><em>fieldName</em> = <em>initialValue</em></div>
|
<div class="synopsis2">[ <em>type</em> ] <em>methodName</em> ([<em>type</em>] <em>var</em>...) { .. } </div>
)*
<div class="synopsis">}</div>
</div>

<p>
クラス定義はJava言語に似た方法で記述されます。
</p>

<p>
Java言語との違いは、
</p>
<ul>
<li>publicクラスしか定義できません - package privateクラスやインタフェースは定義できません
<li>フィールドはJavaBeansのプロパティに対応づけられます
<li>フィールド/メソッド/パラメータの型は定義したり省略したりできます
<li>staticフィールドやstaticメソッドはありません
<li>例外の宣言はありません
<li>コンストラクタ内でのthis()やsuper()はありません。
</ul>

<a name="classdeffile"></a>
<h3>クラス定義ファイル</h3>

クラス定義ファイル（<b>scripted class</b>とも呼ばれる）はJavaクラスを定義します。
特別なクラスローダによってコンパイル・ロードされます。
クラス定義ファイルは、共通のファイル名拡張子'<tt>.pnc</tt>'を持ちます。

<p>
クラス定義ファイルの文法は、以下のように定義されます。

<div class="box">
<div class="synopsis">[ <tt>package</tt> <em>package_name</em> ]</div>
<div class="synopsis">( <tt>import</tt> <em>class_name</em> )*</div>
<div class="synopsis"><tt>class</tt> <em>class_literal</em> [ <tt>extends</tt> <em>superclass</em> ]
[ <tt>implements</tt> <em>interface</em>... ] { ... }</div>
</div>

<div class="eg">例： (<tt>util/mymap.pnc</tt>)
<pre>
package util
import java.util.*
import java.io.*
class mymap extends TreeMap implements Serializable {
  get(key){
    if ((v = super.get(key)) == null){
      super.put(key, v = set())
    }
    v
  }
}
</pre></div>

<a name="inline_classdef2"></a>
<h3>インライン・クラス定義</h3>
<p>
クラス定義は式として使われることもあります。クラス定義が式として使われる場合、そのクラスは新たに作成されたクラスローダによってロードされます。したがって、他のクラスとの依存関係には注意が必要です。
</p>


<a name="builtin"></a>
<h2>5. 組み込み関数</h2>
<P>10個の組み込み関数が用意されています。これらの関数は再定義できません。</P>

<table width=400>
  
    <tr align=center>
      <td><tt>import</tt></td>
      <td><tt>package</tt></td>
      <td><tt>getContext</tt></td>
      <td><tt>throw</tt></td>
      <td><tt>catch</tt></td>
      <td><tt>use</tt></td>
      <td><tt>unuse</tt></td>
    </tr>
    <tr align=center>
      <td><tt>load</tt></td>
      <td><tt>autoload</tt></td>
      <td><tt>require</tt></td>
      <td><tt>loadFile</tt></td>
      <td><tt>eval</tt></td>
      <td><tt>defined</tt></td>
      <td><tt>quit</tt></td>
    </tr>
  
</table>

<a name="import"></a>

<div class="box">
<div class="synopsis"><b>import</b>("<em>class-literal</em>")</div>
<div class="synopsis"><b>import</b> <em>class-literal</em></div>
<div class="synopsis"><b>import static </b> <em>static-member-literal</em></div>
</div>
<p><tt>import()</tt> は <em>class-literal</em> をJava のクラス名として登録します。
参照した変数が未定義の場合、その名前が import
されたクラスであるかどうか検査されます。</p>
<p><em>class-literal</em>は <tt>"java.awt.*"</tt>のようなワイルドカードでもかまいません。</p>
<p>初期状態では、<tt>"java.lang.*"</tt> とデフォルトパッケージ(<tt>"*"</tt>)が登
録されています。
クラスは最後に import されたクラスから順に検索されます。
ただし、ワイルドカードが特定のクラス名を上書きすることはありません(例を参照)。</p>
<div class="eg">例:
<pre>
Object --> java.lang.Object class
import("org.omg.CORBA.*")
Object  --> org.omg.CORBA.Object interface
import("java.lang.Object")
Object --> java.lang.Object class
import("org.omg.CORBA.*")
Object --> java.lang.Object class
</pre></div>

<p>パラメータ <em>class_litral</em>がnullの場合、importされた名前をリセットします</p>

<tt>import static</tt>　はクラスを指定せずに staticフィールドやstaticメソッドにアクセスできるようにします。
<div class="eg">例:
<pre>
import static java.awt.Color.*
blue  --> java.awt.Color[r=0,g=0,b=255]

import static java.util.ResourceBundle.*
getBundle("pnuts.lang.pnuts")
</pre></div>

<div class="box">
<div class="synopsis"><b>import</b>()</div>
</div>

<p>import されているクラスとパッケージ名のリストをもとめます。</p>

<pre class="eg">
import() --> ["java.lang.*", "*"]
import("org.omg.CORBA.Object")
import() --> [org.omg.CORBA.Object interface, "java.lang.*", "*"]
import(null)
import() --> []
</pre>

<a name=packaging></a>
<div class="box">
<div class="synopsis"><b>package</b> ( <em>nameString</em> )</div>
</div>
  
<p><em>nameString</em> パッケージに入ります。
<em>nameString</em> パッケージがなければそのパッケージを作ります。
返り値はnullです。
</p>

<div class="eg">例(1)
<pre>
package()  --> package ""
a = 1
package("foo")      --> enter package "foo"
a      --> 1
a = 2
a      --> 2
::a    --> 1
package("")         --> enter package ""
a      --> 1
foo::a --> 2
</pre></div>

<div class="eg">例(2)
<pre>
package()  --> package ""
function f() 1
package("foo")      --> enter package "foo"
f()      --> 1
function f() 2
f()      --> 2
::f()    --> 1
package("")         --> enter package ""
f()      --> 1
foo::f() --> 2
</pre></div>

<div class="box">
<div class="synopsis"><b>package</b> ()</div>
</div>

<p>カレントパッケージを求めます。</p>
<div class="eg">例:
<pre>
package()   --> package ""
package("foo")
package()   --> package "foo"
package("")
package()   --> package ""
</pre></div>
<p><tt>package()</tt> の結果は <a href="../apidoc/pnuts/lang/Package.html">pnuts.lang.Package</a> オブジェクトです。</p>
<a name="use"></a>
<div class="box">
<div class="synopsis"><b>use</b> ( { <em>module</em> } )</div>
</div>

<p><em>module</em>がStringオブジェクトの場合、次の手順でそのモジュールがコンテクストに追加されます。
<ul>
<li>そのモジュールが初期化されていなければ、初期化スクリプトが実行されます。初期化が成功したときにのみそのモジュールがコンテクストに登録されて利用可能になります。
<li>そのモジュールが初期化済だが、カレント・コンテクストに登録されていない場合は、そのモジュールがカレント・コンテクストのモジュール・リストの先頭に追加されます。
</ul>

<p>
モジュールが正常に登録されると、デフォルトの動作として、そのモジュールが定義する関数が自動的に公開されます。
</p>
<p>
<tt>use()</tt>は、返り値として、モジュールが正常に登録されたかどうかを返します。
</p>

<div class="eg">foo/init.pnut
<pre>
package("foo")
function x() 100
</pre>
</div>

<div class="eg">
<pre>
 use("foo") --> true
 x      --> function x() 100
</pre></div>

<p><em>module</em>がPackageオブジェクトの場合、そのPackageがモジュールとしてマークされて、カレント・コンテクストのモジュール・リストに追加されます。「<a href="module.html#dynamic_modules">動的なモジュール</a>」を参照。

<p><em>module</em>が<tt>null</tt>の場合、コンテクストのモジュールリストを空にします。
<a href="#branch_module_list">「モジュール・リストの枝分かれ」</a>を参照。
<p>
<em>module</em>が省略された場合、現在<tt>use()</tt>されたモジュール名のリストがStringの配列として返されます。
<p>
<div class="eg">例：<pre>
    use() -->  ["foo"]
</pre></div>
<p>
モジュールの概念については<a href="#modules">「モジュール」</a>、モジュールの作り方については<a href="module.html">「Pnutsユーザーズガイド」</a>を参照。</p>

<a name="unuse"></a>
<div class="box">
<div class="synopsis"><b>unuse</b> ( <em>module</em> )</div>
</div>

<p>
<tt>unuse()</tt>は、指定されたモジュールをモジュールリストから削除します。削除された場合はtrueを返します。
</p>

<a name=getContext></a>
<div class="box">
<div class="synopsis"><b>getContext</b> ()</div>
</div>

<p><em>Context</em> は Pnuts インタプリタの内部オブジェクトです。
以下の状態を含みます。</p>
<ul>
  <li>どの Pnuts-パッケージが使われているか
  <li><tt>import()</tt> された Java-パッケージのリスト
  <li><tt>print()</tt> 関数の出力先の OutputStream
  <li><tt>error()</tt> 関数の出力先の OutputStream
  <li>その他
</ul>
<p><tt>getContext()</tt> の結果は、<a
href="../apidoc/pnuts/lang/Context.html"><tt>pnuts.lang.Context</tt></a> オブジェクトです。</p>
<div class="eg">例:
<pre>
getContext().setOutputStream(System::out)
</pre></div>
<p>詳細は <a href="context.html">Pnuts ユーザーズガイド</a> を参照してください。</p>
<P><a name=loading></a></P>
<div class="box">
<div class="synopsis"><b>loadFile</b> ( <em>file_name</em> [ , <em>context</em> ] )</div>
<div class="synopsis"><b>load</b> ( <em>resource</em> [ , <em>context</em> ] )</div>
<div class="synopsis"><b>require</b> ( <em>resource</em> )</div>
<div class="synopsis"><b>autoload</b> ( <em>symbol</em> , <em>resource</em> )</div>
</div>

<p><tt>loadFile()</tt> は、ローカルファイルからスクリプトを読みます。
<tt>load()</tt> は、クラスローダによってスクリプトを検索し、そのスクリプトを読みます。
どちらも、最後の式の結果を返します。</p>

<p>
<tt>import()</tt>の状態はデフォルトの状態にリセットされた上でスクリプトが実行されます。また、カレントパッケージは、パッケージ階層の一番上のパッケージにセットされた状態でスクリプトが実行されます。
</P>

<div class="eg">例:
<pre>
loadFile("/home/my.pnut")
load("examples/pnutsLayout.pnut")
</pre></div>
<p><tt>require()</tt> は、パラメータに指定したスクリプトが読み込まれていない場合や、最後に読み込まれてから変更があった場合にそれを読み込みます。</p>

<p><tt>autoload()</tt> は、シンボルとスクリプトのマッピングをカレントパッケージに登録します。そのパッケージでシンボルをアクセスした時に未定義であった場合に、対応するスクリプトが読み込まれます。
</p>

<p>詳細は <a href="loading.html">Pnuts ユーザーズガイド</a> を参照してください。</p>
<P><a name=eval></a></P>
<div class="box">
<div class="synopsis"><b>eval</b> ( <em>string</em> )</div>
<div class="synopsis"><b>eval</b> ( <em>string</em>, <em>context</em> )</div>
<div class="synopsis"><b>eval</b> ( <em>string</em>, <em>package</em> )</div>
</div>

<div class="eg">例:
<pre>
foo = "YES"
eval("foo.length()") --> 3
</pre>
<p><em>package</em>が指定された場合は、そのパッケージをカレントパッケージとする
Context が作られ、その Context で式を評価します。</p>
<pre class="YES">
eval("a = 100", "pkg")
pkg::a --> 100
</pre></div>
<P>
<a name=exception></a>
<a name=throw></a>
<div class="box">
<div class="synopsis"><b>throw</b> ( <em>exception</em> or <em>string</em> )</div>
<div class="synopsis"><b>throw</b> <em>exception</em> or <em>string</em> </div>
</div>

<p><tt>throw()</tt> は <em>exception</em> に指定された例外か、文字列<em>string</em>が指定された場合は<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/lang/RuntimeException.html">RuntimeException</a>を送出します。</p>
<div class="eg">例:
<pre>
      throw("be careful")
      throw(FileNotFoundException())
</pre></div>

<div class="eg">例:
<pre>
throw new java.io.IOException("message")
</pre>
</div>

<P><a name=catch></a></P>
<div class="box">
<div class="synopsis"><b>catch</b> ( <em>exceptionClass</em><tt>, </tt><em>function</em> )</div>
</div>  

<p><tt>catch()</tt> は、現在のスタックフレームに例外ハンドラを定義します。登録された例外が送出されると、対応するハンドラが実行され、実行中の関数はただちにハンドラの結果を返します。</p>

<p>例外ハンドラのスコープは変数のスコープと同じです。</p>
<div class="eg">例:
<pre>
function func(){
   catch(FileNotFoundException, function (e) "Don't care")
   println(1)
   FileInputStream("file doesn't exist")
   println(2)
}

> func()
1
"Don't care"

> FileInputStream("file doesn't exist")
java.io.FileNotFoundException  : "file doesn't exist"
</pre></div>
<p><em>function</em> が null の場合、その例外ハンドラがキャンセルされます。</p>


<P><a name=finally></a></P>
<div class="box">
<div class="synopsis"><b>finally</b> ( [ </tt><em>tryFunction</em>  , ] </tt><em>finallyFunction</em> )</div>
</div>  
<p>
<em>tryFunction</em>と<em>finallyFunction</em>が指定された場合、まず<em>tryFunction()</em>を実行し、その結果に関らず、<em>finallyFunction()</em>を実行します。つまり、次の式と同じです。

<pre class="eg">
try {
    <em>tryFunction()</em>
} finally {
    <em>functionFunction()</em>
}
</pre>
<p>
<em>finallyFunction</em>のみが指定された場合、現在のスコープから抜けるときに自動的に実行される関数としてその関数が登録されます。
</p>
<pre class="eg">
function test(){
   finally(function () println("done"))
   println("start")
}

> test()
start
done
</pre>


<P><a name="defined"></a></P>
<div class="box">
<div class="synopsis"><b>defined</b> ( <em>symbol</em> )</div>
</div>

<p><tt>defined()</tt> は、任意のスコープで利用でき、指定したシンボルが定義されているかどうかを調べます。</p>
<div class="eg">例: 
<PRE>
> defined("X")
false
> X = 100
100
> defined("X")
true
> X = null
null
> defined("X")
true
</PRE></div>
<p><tt>defined()</tt> はクラスが定義されているかどうかを調べることもできます。</p>
<div class="eg">例: 
<pre>
> defined("Window")
false
> import("java.awt.Window")
null
> defined("Window")
true
</pre></div>

<P><a name=class></a></P>
<div class="box">
<div class="synopsis"><b>class</b> ( "<em>class-literal</em>" )</div>
</div>
  
<p>指定した名前のクラスが存在する場合は、そのClassオブジェクトを返します。
そうでない場合は、nullを返します。</p>
<P><a name=quit></a></P>
<div class="box">
<div class="synopsis"><b>quit</b> ( [ <em>expression</em> ] )</div>
</div>

<p><tt>quit()</tt> は、EOF を読まずに実行を中止します。</p>
 <p>パラメータ<em>expression</em>が指定されたときは、その値がインタプリタセッションの結果になります。
詳しくは、<a href="api.html">Pnuts API</a> を参照してください。</p>
<div class="eg">例
<pre>
(in Java)
   Object ret = Pnuts.load(System.in, true, new Context());
   System.out.println("ret = " + ret);

(in Pnuts)
   quit(123)

------------
   ret = 123
</pre></div>
<P>この関数は、AWT の EventDispatcher 等の non-daemonなスレッドが走っている場合には、プログラムを停止させることができません。
</P>

<a name="sugar"></a>
<h2>6. 文法の拡張</h2>
<p>
算術演算("+", "-" 等)のパラメータや、インスタンス変数の参照等を行うオブジェクトが特定のインタフェースを実装する場合、そのインタフェースの決められたメソッドを呼び出すという規則が設けられており、本来はすべてメソッド呼び出しの形で書かなければならない式をより簡潔に記述することができます。
</p>

<a name=arithmeticExtension></a>
<h3>算術演算</h3>
<p><a href="../apidoc/pnuts/lang/Numeric.html"><tt>pnuts.lang.Numeric</tt></a>インタフェースを実装するクラスのインスタンスが含まれる算術演算は、それぞれきめられたメソッド呼び出しに対応づけられます。</p>

<pre class="eg">
public interface Numeric {
    Object add(Object o);
    Object subtract(Object o);
    Object multiply(Object o);
    Object divide(Object o);
    Object negate();
    Object inverse();
    int compareTo(Object o);

    int NOT_EQUAL = 2;
    int LEFT_IS_BIGGER = 1;
    int RIGHT_IS_BIGGER = -1;
    int EQUAL = 0;
}
</pre>

<p>第1引数が <a href="../apidoc/pnuts/lang/Numeric.html"><tt>pnuts.lang.Numeric</tt></a> オブジェクトの場合、対応するメソッドが呼ばれます。</p>

<div class="eg">例:
<pre>
Numeric n1, n2;
n1 + n2     -->  n1.add(n2)
n1 - n2     -->  n1.subtract(n2)
n1 * n2     -->  n1.multiply(n2)
n1 / n2     -->  n1.divide(n2)
n1 > n2     -->  n1.compareTo(n2) == LEFT_IS_BIGGER
- n1        -->  n1.negate()
</pre></div>
<p>
加算("+")と乗算("*")は交換則が成り立つことを仮定します。もし、第2引数がNumeric オブジェクトで第1引数が Number オブジェクトの場合、演算の順序を反転させて<tt>add()</tt> メソッドと <tt>multiply()</tt> メソッドをそれぞれ適用します。
</p>
<p>
引算の第2引数が Numeric オブジェクトで、第1引数がNumber オブジェクトの場合、第2引数に<tt>negate()</tt>メソッドが適用されて第1引数に加算されます。
</p>
<p>除算の第2引数が Numeric オブジェクトで、第1引数がNumber オブジェクトの場合、第2引数に<tt>inverse()</tt> メソッドが適用されて第1引数と乗算されます。</p>

<a name="units"></a>
<h3>単位</h3>
<a href="../apidoc/pnuts/lang/QuantityFactory.html">QuantityFactory</a> は次のように定義されています。
<pre class="eg">
package pnuts.lang;

public interface QuantityFactory {
   public Object make(Number number, String unitName);
}
</pre>
<p>単位の名前は、<a href="../apidoc/pnuts/lang/Context.html#registerQuantityFactory(java.lang.String, pnuts.lang.QuantityFactory)"><tt>Context.registerQuantityFactory(String, QuantityFactory)</tt></a> メソッドであらかじめ登録しておきます。登録された単位名が10進数のすぐあとに現れると、対応するQuantityFactory オブジェクトの <tt>make()</tt> メソッドが呼ばれ、戻り値が式の値になります。
</p>
<p><tt>make()</tt>メソッドの戻り値は Numeric オブジェクトにすることが多く、その場合、算術演算が適用できます。</p>
<div class="eg">例:
<pre>
10cm - 1in    --> 7.460cm
0.5cm - 0.1in --> 0.246cm
</pre></div>

<P><a name="indexed"></a></P>
<h3>インデックスへのアクセス</h3>
<p><a href="../apidoc/pnuts/lang/Indexed.html"><tt>pnuts.lang.Indexed</tt></a>に対するインデックスへのアクセスを行うと、そのインタフェースに対するメソッドが呼び出されます。</p>
<p><tt>pnuts.lang.Indexed</tt> インタフェースは次のように定義されています。</p>
<pre class="eg">
package pnuts.lang;

public interface Indexed {
    void set(int idx, Object value);
    Object get(int idx);
}
</pre>
<div class="eg">例:
<pre>
i1 = anIndexed
i1[0]          -->  i1.get(0)
i1[0] = 18     -->  i1.set(0, 18)
</pre></div>
<p>J2SE 環境では、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/util/List.html"><tt>java.util.List</tt></a> オブジェクトへのインデックスアクセスは、<tt>List.get(int)</tt>または<tt>List.set(int, Object)</tt>メソッドを呼び出します。</P>
<P><a name=member></a></P>
<h3>メンバーの参照と代入</h3>
<p><a href="../apidoc/pnuts/lang/Property.html"><tt>pnuts.lang.Property</tt></a>インタフェースを実装するクラスのインスタンスに対するメンバーの参照(代入)は、<tt>get</tt> (<tt>set</tt>) メソッドの呼び出しに対応づけられます。</p>
<p><tt>pnuts.lang.Property</tt> インタフェースは次のように定義されています。</p>
<pre class="eg">
package pnuts.lang;

public interface Property {
    void set(String name, Object value, Context context);
    Object get(String name, Context context);
}
</pre>
<div class="eg">例:
<pre>
p1 = aProperty
p1.name          -->  p1.get("name")
p1.age = 18      -->  p1.set("age", 18)
</pre></div>
<p><tt>pnuts.lang.Package</tt> クラスは
<tt>pnuts.lang.Property</tt> インタフェースを実装しているので、
Package オブジェクトにはドット記法が使えます。</p>
<div class="eg">例: 
<pre>
package(&quot;foo&quot;)
p1 = package()
package(&quot;&quot;)
p1.msg = &quot;yes&quot;   == p1.set(&quot;msg&quot;, &quot;yes&quot;) == foo::msg = &quot;yes&quot;</pre></div>
<p>J2SE 環境では、<a href="http://java.sun.com/j2se/1.4/ja/docs/ja/api/java/util/Map.html"><tt>java.util.Map</tt></a> オブジェクトへのフィールドアクセスは、<tt>Map.get(Object)</tt>または<tt>Map.put(Object, Object)</tt>メソッドを呼び出します。</P>
<P><a name=methodCall></a></P>
<h3>メソッド呼び出し</h3>
<p><a href="../apidoc/pnuts/lang/AbstractData.html"><tt>pnuts.lang.AbstractData</tt></a>インタフェースを実装するクラスのインスタンスへのメソッド呼び出しは、<tt>invoke()</tt>メソッドの呼び出しに対応づけられます。</p>
<p><tt>pnuts.lang.AbstractData</tt> インタフェースは次のように定義されています。</p>
<pre class="eg">
package pnuts.lang;

public interface AbstractData extends Property {
    Object invoke(String name, Object args[], Context context);
}
</pre>
<div class="eg">例:
<pre>
d1 = anAbstractData
d1.work(1,2,3)   -->   d1.invoke("work", [1,2,3], getContext())
</pre></div>

<P><a name=syntax></a></P>
<h2>7. 構文規則</h2>
<p>以下は Pnuts の構文規則をEBNFで定義したものです（一部JavaCCの記法が混じっています）。</p>

<pre class=wb>
INTEGER_LITERAL =  DECIMAL_LITERAL | HEX_LITERAL1 | HEX_LITERAL2 ;
DECIMAL_LITERAL = ("0"-"9")+, ( LETTER )* ;
HEX_LITERAL1 = "#", ("0"-"9","a"-"f","A"-"F")+ ;
HEX_LITERAL2 = "0", ("x" | "X"), ("0"-"9"|"a"-"f"|"A"-"F")+, ( LETTER )*;
FLOATING_POINT_LITERAL = ("0"-"9")+, ".", ("0"-"9")+, [ EXPONENT ], ( LETTER )* |
                           ".", ("0"-"9")+, [ EXPONENT ],  ( LETTER )* |
                          ("0"-"9")+,  EXPONENT, ( LETTER )* ;
EXPONENT = ( "e" |"E" ), ["+" | "-"], ("0"-"9")+ ;
UNICODE_ESCAPE = ("u" | "U"),
                 ( "0"-"9" | "a"-"f" | "A"-"F"),
                 ( "0"-"9" | "a"-"f" | "A"-"F"),
                 ( "0"-"9" | "a"-"f" | "A"-"F"),
                 ( "0"-"9" | "a"-"f" | "A"-"F") ;
CHARACTER_LITERAL = "'", ( ~["'","\\","\n","\r"] |
                           "\\" ( "n" | "t" | "b" | "r" | "f" | "0" |
                           "\\" | "'" | "\"" | UNICODE_ESCAPE ) ) "'" ;
STRING_LITERAL = "\""( ( ~["\"","\\"]) |
                           ("\\" ( "\\" | (~["\\"]) ) ) )* "\"" ;
STRING_LITERAL2 = "`" ( ~["`"] )* "`" ;
IDENTIFIER = LETTER ( LETTER | DIGIT )* ;
LETTER = "\u0024" | "\u0040"-"\u005a" | "\u005f" | "\u0061"-"\u007a" | "\u0080"-"\uffff" ;
DIGIT = "0"-"9" ;
IDENTIFIER: LETTER ( LETTER | DIGIT )* ;
COMMAND_HEADER = "#!" (~["\n","\r"])* ("\r\n" | "\n" | "\r") ;
EOL = "\r" | "\n" "\r\n" ;
Eol = ( EOL )* ;
StartSet = [ COMMAND_HEADER ] Eol ( (ExpressionList ( EOL [ ExpressionList ] )* EOF)  |
                                       EOF ) ;
Start = [ ExpressionList ] ( EOL | EOF ) ;
ExpressionList =  Expression (";" [ Expression ] )* |
                    ";" ;
Expression = MultiAssignLHS "=" Expression |
             ConditionalExpression [ Assignment ] |
             StatementExpression ;
MultiAssignLHS = IdNode "," IdNode ("," IdNode )*
ArgumentExpression = ConditionalExpression [ Assignment ] |
               StatementExpression ;
PrimaryExpression = PrimaryPrefix ( PrimarySuffix )* ;
IdNode = [ "::" ] IDENTIFIER ;
PrimaryPrefix = Literal | IdNode | MapElements | Class | New |
                "[" ListElements "]" |
                "{" ListElements "}" |
                "(" Eol Expression Eol ")" ;
ListElements = Eol [ ArgumentExpression Eol ( "," Eol ArgumentExpression Eol )* ] ;
MapElements = "{" Eol MapElement ("," Eol MapElement)* Eol "}" ;
MapElement = Expression "=&gt;" Expression ;
Class = "class" [ ClassName ] ;
New = "new" ClassName ( (" ListElements ")" [ ClassDefBody ] |
                          ( ArraySuffix )+ [ "{" ListElements "}" ] ) ;
ClassDef = "class" ClassName
           [ "extends" ClassName ]
           [ "implements" ClassName ( "," ClassName)* ]
           ClassDefBody
ClassDefBody = "{" Eol (MethodDef | FieldDef)* "}" ;
MethodDef = [ ClassName ] IDENTIFIER TypedParamList Eol Block2 Eol ;
FieldDef = [ ClassName ] IDENTIFIER [ "=" Expression ]
ArraySuffix = "[" Eol ( "]" | Expression Eol "]" ) ;
ClassName = Package ( "." Package )* ;
Package = IDENTIFIER ;
MethodNode = "." IDENTIFIER "("  ListElements ")" ;
StaticMethodNode = "::" IDENTIFIER "("  ListElements ")" ;
MemberNode = "." ( IDENTIFIER | "class" ) ;
StaticMemberNode = "::" IDENTIFIER ;
ApplicationNode = "(" ListElements ")" ;
PrimarySuffix = "[" Eol ( "]" |
                          Expression Eol ( ".." Eol ( "]" |
                             	                      Expression Eol "]" ) |
                                           "]" ) ) |
                   MethodNode | StaticMethodNode | MemberNode |
                   StaticMemberNode | ApplicationNode ;
Literal = INTEGER_LITERAL | FLOATING_POINT_LITERAL | CHARACTER_LITERAL |
            STRING_LITERAL | STRING_LITERAL2 | BooleanLiteral | NullLiteral ;
BooleanLiteral = "true" | "false" ;
NullLiteral = "null" ;
Assignment = ("=" | "*=" | "%=" | "/=" | "+=" | "-=" | "&lt;&lt;=" | "&gt;&gt;=" | "&gt;&gt;&gt;=" | "&amp;=" | "^=" | "|=")   Eol Expression ;
ConditionalExpression = ConditionalOrExpression [ "?" Eol Expression ":" Eol ConditionalExpression ] ;
ConditionalOrExpression = ConditionalAndExpression ( Eol "||" Eol ConditionalAndExpression )* ;
ConditionalAndExpression = InclusiveOrExpression ( Eol "&amp;&amp;" Eol InclusiveOrExpression  )* ;
InclusiveOrExpression = ExclusiveOrExpression ( Eol "|" Eol ExclusiveOrExpression  )* ;
ExclusiveOrExpression = AndExpression ( Eol "^" Eol AndExpression )* ;
AndExpression = EqualityExpression ( Eol "&amp;" Eol EqualityExpression  )* ;
EqualityExpression = InstanceofExpression ( Eol ( "==" Eol InstanceofExpression |
                                                    "!=" Eol InstanceofExpression ) )* ;
InstanceofExpression = RelationalExpression [ Eol "instanceof" Type ] ;
RelationalExpression = ShiftExpression ( Eol (  ("&lt;" | "&gt;" | "&lt;=" | "&gt;=") Eol ShiftExpression )*;
ShiftExpression = AdditiveExpression ( Eol ( ( "&lt;&lt;" | "&gt;&gt;" | "&gt;&gt;&gt;" ) Eol AdditiveExpression ))*;
AdditiveExpression = MultiplicativeExpression ( Eol ( ( "+" | "-" ) Eol MultiplicativeExpression ))*;
MultiplicativeExpression = UnaryExpression ( Eol ( ("*" | "/" | "%") Eol UnaryExpression ))* ;
UnaryExpression = "+" UnaryExpression |
                    "-" UnaryExpression |
                    "++" PrimaryExpression |
                    "--" PrimaryExpression |
                     UnaryExpressionNotPlusMinus ;
UnaryExpressionNotPlusMinus = "~" UnaryExpression |
                                "!" UnaryExpression |
                                CastExpression |
                                PostOpe ;
CastExpression = "(" Eol Type Eol ")" UnaryExpressionNotPlusMinus ;
Type = ClassName (PrimarySuffix)* ;
PostOpe = PrimaryExpression  [ "++" | "--" ] ;
StatementExpression = IfStatement | WhileStatement | DoStatement | ForeachStatement |
                      ForStatement | SwitchStatement | Break | Continue | Return |
                      Yield | FunctionStatement | TryStatement | CatchNode |
                      FinallyNode | Import | ThrowNode ;
Break =  "break" [ Expression ] ;
Continue = "continue" ;
Return = "return" [ Expression ] ;
Yield = "yield" [ Expression ] ;
Import = "import"  [ "static" ]  [ Package ( "." Package )* ["." "*" ] |
                                      "*") |
                                      "(" [ Expression ] ")" ] ;
Block = "{" Eol [ Expression ((";" |EOL) [ Expression ] )* ] "}" |
          Expression (";" [ Expression ] )*  |
          ";" ;
Block2 = "{" Eol [ Expression ((";" |EOL) [ Expression ] )* ] "}" ;
IfStatement = "if" Eol "(" Eol Expression Eol ")" Eol Block ( ElseIfNode )* [ ElseNode ] ;
ElseIfNode = Eol "else" "if" "(" Eol Expression Eol ")" Eol Block ;
ElseNode = Eol "else" Eol Block ;
WhileStatement = "while" Eol "(" Eol Expression Eol ")" Eol Block ;
TryStatement = "try" Eol Block2 ( Eol CatchBlock )* [ Eol FinallyBlock ] ;
CatchBlock =  "catch" "(" ClassName IDENTIFIER ")" Eol Block2 ;
CatchNode =  "catch" [ "(" Eol Expression Eol "," Eol Expression Eol ")" ] ;
FinallyNode = "finally" [ "(" Eol Expression Eol [ "," Eol Expression Eol ] ")" ] ;
ThrowNode = "throw" [ Expression ] ;
FinallyBlock = "finally" Eol Block2 ;
DoStatement = "do" Eol Block2 Eol "while" Eol "(" Eol Expression Eol ")"  ;
ForStatement = "for" Eol "(" Eol ( ForEnum |
                                     [ ForInit ] ";" Eol [ Expression Eol ] ";" Eol [ ForUpdate ] ) ")" Eol Block ;
ForEnum = IDENTIFIER (, IDENTIFIER)* Eol ":" Eol Expression Eol [ ".." Eol Expression Eol ] ;
ForInit = Local Eol ( "," Eol Local Eol )* ;
ForUpdate =  Expression Eol ( "," Eol Expression Eol )* ;
Local = IDENTIFIER "=" Eol Expression ;
ForeachStatement = "foreach" Eol t1 = IDENTIFIER ( "[" ListElements "]" |
                                                    "(" Eol Expression Eol ")" ) Eol Block ;
SwitchStatement = "switch" Eol "(" Eol  Expression Eol ")"  Eol
                   "{" Eol ( SwitchLabel SwitchBlock )*  "}" ;
SwitchBlock = Block2 | [ Expression ] ( (";" | EOL ) [ Expression ] )* ;
SwitchLabel = "case" Expression ":" | "default" ":" ;
FunctionStatement = "function" [ IDENTIFIER ] ParamList Eol Block ;
ParamList = "(" [ Param ( "," Param )* [ "[" "]" ]) ] ")" ;
Param = Eol IDENTIFIER Eol ;
TypedParam = Param | ClassName Param ;
TypedParamList = "(" ( ")" | TypedParam ("," TypedParam  )* ")" ) ;
</pre>
<!-- body end -->


<div class="nav2"><a href="lang-TOC.html">目次</a> -> Pnuts 言語</div>


</body>
</html>
